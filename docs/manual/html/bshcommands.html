<?xml version="1.0" encoding="UTF-8"?>
<html><head><title>BeanShell Commands Documentation</title></head><body bgcolor="ffffff"><table cellspacing="10"><tr><td align="center"><a href="http://www.beanshell.org/"><img src="../images/homebutton.gif"/><br/>Home</a></td><td><a href="credit.html#Credit_and_Acknowledgments"><img src="../images/backbutton.gif"/><br/>Back
			</a></td><td align="center"><a href="contents.html"><img src="../images/upbutton.gif"/><br/>Contents</a></td><td align="center"><img src="../images/forwardbutton.gif"/><br/>Next
			</td></tr></table><h1>BeanShell Commands Documentation</h1>
	

The following documentation was generated automatically by 'BshDoc' from 
Javadoc style comments in the BeanShell command script files.  See "BshDoc"
for more information.
<p CLEAR="ALL"/>


<?xml-stylesheet type="text/xsl" href="bshcommands.xsl"?>
<!-- This file was auto-generated by the bshdoc.bsh script -->
<p/><table width="100%" border="1" cellpadding="2"><tr><td width="20%"><strong><a href="#addClassPath">addClassPath</a></strong></td><td>void addClassPath( string | URL )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#bg">bg</a></strong></td><td>Thread bg( String filename )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#bind">bind</a></strong></td><td>bind ( bsh .This ths , bsh .NameSpace namespace ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#browseClass">browseClass</a></strong></td><td>void browseClass( String | Object | Class )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#cat">cat</a></strong></td><td>cat ( String filename ) <br CLEAR="ALL"/>cat ( URL url ) <br CLEAR="ALL"/>cat ( InputStream ins ) <br CLEAR="ALL"/>cat ( Reader reader ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#cd">cd</a></strong></td><td>void cd ( String pathname ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#classBrowser">classBrowser</a></strong></td><td>classBrowser ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#clear">clear</a></strong></td><td>clear ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#cp">cp</a></strong></td><td>cp ( String fromFile , String toFile ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#debug">debug</a></strong></td><td>debug ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#desktop">desktop</a></strong></td><td>desktop ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#dirname">dirname</a></strong></td><td>String dirname ( String pathname ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#editor">editor</a></strong></td><td>editor ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#error">error</a></strong></td><td>void error ( item ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#eval">eval</a></strong></td><td>Object eval ( String expression ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#exec">exec</a></strong></td><td>exec ( String arg ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#exit">exit</a></strong></td><td>exit ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#extend">extend</a></strong></td><td>This extend( This object )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#fontMenu">fontMenu</a></strong></td><td>fontMenu ( component ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#frame">frame</a></strong></td><td>Frame | JFrame | JInternalFrame frame( Component component )

<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getBshPrompt">getBshPrompt</a></strong></td><td>String getBshPrompt ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getClass">getClass</a></strong></td><td>Class getClass ( String name ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getClassPath">getClassPath</a></strong></td><td>URL [ ] getClassPath ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getResource">getResource</a></strong></td><td>URL getResource ( String path ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getSourceFileInfo">getSourceFileInfo</a></strong></td><td>getSourceFileInfo ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#importCommands">importCommands</a></strong></td><td>void importCommands( resource path | package name )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#importObject">importObject</a></strong></td><td>void importObject( Object object )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#javap">javap</a></strong></td><td>void javap( String | Object | Class | ClassIdentifier )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#load">load</a></strong></td><td>Object load ( String filename ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#makeWorkspace">makeWorkspace</a></strong></td><td>makeWorkspace ( String name ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#mv">mv</a></strong></td><td>mv ( String fromFile , String toFile ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#object">object</a></strong></td><td>This object()
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#pathToFile">pathToFile</a></strong></td><td>File pathToFile ( String filename ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#print">print</a></strong></td><td>void print ( arg ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#printBanner">printBanner</a></strong></td><td>printBanner ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#pwd">pwd</a></strong></td><td>pwd ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#reloadClasses">reloadClasses</a></strong></td><td>void reloadClasses( [ package name ] )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#rm">rm</a></strong></td><td>boolean rm ( String pathname ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#run">run</a></strong></td><td>run ( String filename , Object runArgument ) <br CLEAR="ALL"/>run ( String filename ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#save">save</a></strong></td><td>void save ( Object obj , String filename ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#server">server</a></strong></td><td>void server ( int port ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setAccessibility">setAccessibility</a></strong></td><td>setAccessibility ( boolean b ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setClassPath">setClassPath</a></strong></td><td>void setClassPath( URL [] )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setFont">setFont</a></strong></td><td>Font setFont ( Component comp , String family , int style , int size ) <br CLEAR="ALL"/>Font setFont ( Component comp , int size ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setNameCompletion">setNameCompletion</a></strong></td><td>void setNameCompletion ( boolean bool ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setNameSpace">setNameSpace</a></strong></td><td>setNameSpace ( ns ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setStrictJava">setStrictJava</a></strong></td><td>void setStrictJava ( boolean val ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#show">show</a></strong></td><td>show ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#source">source</a></strong></td><td>Object source ( String filename ) <br CLEAR="ALL"/>Object source ( URL url ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#sourceRelative">sourceRelative</a></strong></td><td>sourceRelative ( String file ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#thinBorder">thinBorder</a></strong></td><td>public thinBorder ( ) <br CLEAR="ALL"/>public thinBorder ( Color lightColor , Color darkColor ) <br CLEAR="ALL"/>public thinBorder ( Color lightColor , Color darkColor , boolean rollOver ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#unset">unset</a></strong></td><td>void unset ( String name ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#which">which</a></strong></td><td>which( classIdentifier | string | class )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#workspaceEditor">workspaceEditor</a></strong></td><td>workspaceEditor ( Interpreter parent , String name ) <br CLEAR="ALL"/></td></tr></table><p/><!--PAGE BREAK--><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="addClassPath"><strong><font size="+2">addClassPath</font></strong></a><br CLEAR="ALL"/><font size="+1">void addClassPath( string | URL )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Add the specified directory or JAR file to the class path.
	e.g.
	<p>
	<pre>
    addClassPath( "/home/pat/java/classes" );
    addClassPath( "/home/pat/java/mystuff.jar" );
    addClassPath( new URL("http://myserver/~pat/somebeans.jar") );
	</pre>
	<p>
	See <a href="classpath.html">Class Path Management</a>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="bg"><strong><font size="+2">bg</font></strong></a><br CLEAR="ALL"/><font size="+1">Thread bg( String filename )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Source a command in its own thread in the caller's namespace
	<p>

	This is like run() except that it runs the command in its own thread.  
	Returns the Thread object control.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="bind"><strong><font size="+2">bind</font></strong></a><br CLEAR="ALL"/><font size="+1">bind ( bsh .This ths , bsh .NameSpace namespace ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Bind a bsh object into a particular namespace and interpreter

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="browseClass"><strong><font size="+2">browseClass</font></strong></a><br CLEAR="ALL"/><font size="+1">void browseClass( String | Object | Class )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Open the class browser to view the specified class.  
	If the argument is a string it is considered to be a class name.  
	If the argument is an object, the class of the object is used.  
	If the arg is a class, the class is used.
	<p>

	Note: To browse the String class you can't supply a String.
	You'd have to do:  browseClass( String.class );
	<p>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="cat"><strong><font size="+2">cat</font></strong></a><br CLEAR="ALL"/><font size="+1">cat ( String filename ) <br CLEAR="ALL"/>cat ( URL url ) <br CLEAR="ALL"/>cat ( InputStream ins ) <br CLEAR="ALL"/>cat ( Reader reader ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the contents of filename, url, or stream (like Unix cat)

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="cd"><strong><font size="+2">cd</font></strong></a><br CLEAR="ALL"/><font size="+1">void cd ( String pathname ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Change working directory for dir(), etc. commands (like Unix cd)

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="classBrowser"><strong><font size="+2">classBrowser</font></strong></a><br CLEAR="ALL"/><font size="+1">classBrowser ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Open the class browser.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="clear"><strong><font size="+2">clear</font></strong></a><br CLEAR="ALL"/><font size="+1">clear ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Clear all variables, methods, and imports from this namespace.
	If this namespace is the root, it will be reset to the default 
	imports.
	See NameSpace.clear();
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="cp"><strong><font size="+2">cp</font></strong></a><br CLEAR="ALL"/><font size="+1">cp ( String fromFile , String toFile ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Copy a file (like Unix cp).

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="debug"><strong><font size="+2">debug</font></strong></a><br CLEAR="ALL"/><font size="+1">debug ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Toggle on and off debug mode. 
	Debug output is verbose and generally useful only for developers.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="desktop"><strong><font size="+2">desktop</font></strong></a><br CLEAR="ALL"/><font size="+1">desktop ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
 * Start the BeanShell GUI desktop in a JFrame.  A starter workspace is created
 * and added to the desktop.
 *
 * @method void desktop()
 *
 * @author Pat Niemeyer
 * @author Daniel Leuck
 
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="dirname"><strong><font size="+2">dirname</font></strong></a><br CLEAR="ALL"/><font size="+1">String dirname ( String pathname ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Return directory portion of path based on the system default file separator.
	Note: you should probably use pathToFile() to localize the path relative
	to BeanShell's working directory and then file.getAbsolutePath() to get
	back to a system localized string.
	<p>
	
	Example: to change to the directory that contains the script we're 
	currently executing:

	<pre>
	// Change to the directory containing this script
	path=pathToFile( getSourceFileInfo() ).getAbsolutePath();
	cd( dirname( path ) );
	</pre>

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="editor"><strong><font size="+2">editor</font></strong></a><br CLEAR="ALL"/><font size="+1">editor ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Open a GUI editor from the command line or in the GUI desktop mode.
	When run from the command line the editor is a simple standalone
	frame.  When run inside the GUI desktop it is a workspace editor.
	See workspaceEditor()

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="error"><strong><font size="+2">error</font></strong></a><br CLEAR="ALL"/><font size="+1">void error ( item ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the item as an error.  
	In the GUI console the text will show up in (something like) red, 
	else it will be printed to standard error.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="eval"><strong><font size="+2">eval</font></strong></a><br CLEAR="ALL"/><font size="+1">Object eval ( String expression ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Evaluate the string in the current interpreter (see source()).
	Returns the result of the evaluation or null.
	<p>

	Evaluate a string as if it were written directly in the current scope, 
	with side effects in the current scope.
	<p>
	e.g.
    <code><pre>
    a=5;
    eval("b=a*2");
    print(b); // 10
    </pre></code>
	<p>

	eval() acts just like invoked text except that any exceptions generated
	by the code are captured in a bsh.EvalError.  This includes ParseException
	for syntactic errors and TargetError for exceptions thrown by the evaluated
	code.
	<p>
	e.g.
    <pre>
    try {
        eval("foo>>><>M>JK$LJLK$");
    } catch ( EvalError e ) {
        // ParseException caught here
    }

    try {
        eval("(Integer)true");  // illegal cast
    } catch ( EvalError e ) {
        // TargetException caught here
        print( e.getTarget() )  // prints ClassCastException
    }
    </pre>
	<p>
	
	If you want eval() to throw target exceptions directly, without wrapping
	them, you can simply redefine own eval like so:

    <pre>
    myEval( String expression ) {
        try {
            return eval( expression );
        } catch ( TargetError e ) {
            throw e.getTarget();
        }
    }
    </pre>
	<p/>

	Here is a cute example of how to use eval to implement a dynamic cast.  
	i.e. to cast a script to an arbitrary type by name at run-time where the
	type is not known when you are writing the script.  In this case the type
	is in the variable interfaceType.
	<pre>
    reference = eval( "("+interfaceType+")this" );
	</pre>

	<p>
	Returns the value of the expression.
	<p>
	Throws bsh.EvalError on error
	<p>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="exec"><strong><font size="+2">exec</font></strong></a><br CLEAR="ALL"/><font size="+1">exec ( String arg ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Start an external application using the Java Runtime exec() method.
	Display any output to the standard BeanShell output using print().

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="exit"><strong><font size="+2">exit</font></strong></a><br CLEAR="ALL"/><font size="+1">exit ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Conditionally exit the virtual machine.
	Call System.exit(0) unless bsh.system.shutdownOnExit == false.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="extend"><strong><font size="+2">extend</font></strong></a><br CLEAR="ALL"/><font size="+1">This extend( This object )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Return a new object that is a child of the specified object.
	<strong>
	Note: this command will likely change along with a better inheritance 
	mechanism for bsh in a future release.</strong>
	<p>

	extend() is like the object() command, which
	creates a new bsh scripted object, except that the namespace of
	the new object is a child of the parent object. 
	<p>

	For example:
	<p>

    <pre>
    foo=object();
    bar=extend(foo);

    is equivalent to:
      
    foo() { 
        bar() {
            return this; 
        }
    }

    foo=foo();
    bar=foo.bar();

    and also:
     
    oo=object();
    ar=object();
    ar.namespace.bind( foo.namespace );
    </pre>
	<p>

	The last example above is exactly what the extend() command does.
	In each case the bar object inherits variables from foo in the usual way.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="fontMenu"><strong><font size="+2">fontMenu</font></strong></a><br CLEAR="ALL"/><font size="+1">fontMenu ( component ) <br CLEAR="ALL"/></font></td></tr><tr><td>
 * Creates a font menu for use with the workspace and workspace editors
 *
 * @return a font menu
 *
 * @author Daniel Leuck
 
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="frame"><strong><font size="+2">frame</font></strong></a><br CLEAR="ALL"/><font size="+1">Frame | JFrame | JInternalFrame frame( Component component )

<br CLEAR="ALL"/></font></td></tr><tr><td>
    Show component in a frame, centered and packed, handling disposal with
	the close button.
	<p>

	Display the component, centered and packed, in a Frame, JFrame, or 
	JInternalFrame.  Returns the frame.  If the GUI desktop is running then a 
	JInternaFrame will be used and automatically added to the desktop.  
	Otherwise if Swing is available a top level JFrame will be created.  
	Otherwise a plain AWT Frame will be created.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getBshPrompt"><strong><font size="+2">getBshPrompt</font></strong></a><br CLEAR="ALL"/><font size="+1">String getBshPrompt ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Get the value to display for the bsh interactive prompt.
	This command checks for the variable bsh.prompt and uses it if set.
	else returns "bsh % "
	<p/>
	Remember that you can override bsh commands simply by defining the method
	in your namespace. e.g. the following method displays the current working
	directory in your prompt:
	<p/>
	<pre>
	String getBshPrompt() {
		return bsh.cwd + " % ";
	}
	</pre>

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getClass"><strong><font size="+2">getClass</font></strong></a><br CLEAR="ALL"/><font size="+1">Class getClass ( String name ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Get a class through the current namespace utilizing the current imports,
	extended classloader, etc.
	<p>

	This is equivalent to the standard Class.forName() method for class loading,
	however it takes advantage of the BeanShell class manager so that added 
	classpath will be taken into account.  You can also use Class.forName(), 
	however if you have modified the classpath or reloaded classes from within 
	your script the modifications will only appear if you use the getClass() 
	command.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getClassPath"><strong><font size="+2">getClassPath</font></strong></a><br CLEAR="ALL"/><font size="+1">URL [ ] getClassPath ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
    Get the current classpath including all user path, extended path, and the
    bootstrap JAR file if possible.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getResource"><strong><font size="+2">getResource</font></strong></a><br CLEAR="ALL"/><font size="+1">URL getResource ( String path ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Get a resource from the BeanShell classpath.
	This method takes into account modification to the BeanShell class path via
	addClassPath() and setClassPath();

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getSourceFileInfo"><strong><font size="+2">getSourceFileInfo</font></strong></a><br CLEAR="ALL"/><font size="+1">getSourceFileInfo ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Return the name of the file or source from which the current interpreter
	is reading.  Note that if you use this within a method, the result will
	not be the file from which the method was sourced, but will be the file 
	that the caller of the method is reading.   Methods are sourced once but
	can be called many times... Each time the interpreter may be associated
	with a different file and it is that calling interpreter that you are
	asking for information.
	<p>

	Note: although it may seems like this command would always return the
	getSourceFileInfo.bsh file, it does not since it is being executed after
	sourcing by the caller's interpreter.
	If one wanted to know the file from which a bsh method was sourced one
	would have to either capture that info when the file was sourced (by
	saving the state of the getSourceFileInfo() in a variable outside of
	the method or more generally we could add the info to the BshMethod class
	so that bsh methods remember from what source they were created...

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="importCommands"><strong><font size="+2">importCommands</font></strong></a><br CLEAR="ALL"/><font size="+1">void importCommands( resource path | package name )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Import scripted or compiled BeanShell commands in the following package
	in the classpath.  You may use either "/" path or "." package notation.
	e.g. 
	<pre>
		// equivalent
		importCommands("/bsh/commands")
		importCommands("bsh.commands")
	<pre>

	When searching for a command each path will be checked for first, a file
	named 'command'.bsh and second a class file named 'command'.class.
	<p/>

	You may add to the BeanShell classpath using the addClassPath() or
	setClassPath() commands and then import them as usual.
	<pre>
		addClassPath("mycommands.jar");
		importCommands("/mypackage/commands");
	</pre>
	<p/>

	If a relative path style specifier is used then it is made into an absolute
	path by prepending "/".  Later imports take precedence over earlier ones.
	<p/>

	Imported commands are scoped just like imported clases.
	<p/>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="importObject"><strong><font size="+2">importObject</font></strong></a><br CLEAR="ALL"/><font size="+1">void importObject( Object object )
<br CLEAR="ALL"/></font></td></tr><tr><td>
    Import an instance object into this namespace
    (analogous to static class imports).
    You can import the methods and fields of a Java object instance into
    a BeanShell namespace.  e.g.

    <pre>
        Map map = new HashMap();
        importObject( map );
        put("foo", "bar");
        print( get("foo") ); // "bar"
    </pre>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="javap"><strong><font size="+2">javap</font></strong></a><br CLEAR="ALL"/><font size="+1">void javap( String | Object | Class | ClassIdentifier )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the public fields and methods of the specified class (output similar 
	to the JDK javap command).
	<p/>
	If the argument is a string it is considered to be a class name.  If the
	argument is an object, the class of the object is used.  If the arg is a
	class, the class is used.  If the argument is a class identifier, the class
	identified by the class identifier will be used. e.g.  If the argument is
	the empty string an error will be printed.
	<p/>
	<pre>
	// equivalent
	javap( java.util.Date ); // class identifier
	javap( java.util.Date.class ); // class
	javap( "java.util.Date" ); // String name of class
	javap( new java.util.Date() ); // instance of class
	</pre>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="load"><strong><font size="+2">load</font></strong></a><br CLEAR="ALL"/><font size="+1">Object load ( String filename ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Load a serialized Java object from filename.  Returns the object.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="makeWorkspace"><strong><font size="+2">makeWorkspace</font></strong></a><br CLEAR="ALL"/><font size="+1">makeWorkspace ( String name ) <br CLEAR="ALL"/></font></td></tr><tr><td>
 * Creates a JConsole in a JInternalFrame and adds it to the desktop 
 *
 * @return this (the workspace scripted object for allowing access to the 
 *          frame, interpreter, etc.)
 *
 * @author Pat Niemeyer
 * @author Daniel Leuck (bug fixes)
 
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="mv"><strong><font size="+2">mv</font></strong></a><br CLEAR="ALL"/><font size="+1">mv ( String fromFile , String toFile ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Rename a file (like Unix mv).

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="object"><strong><font size="+2">object</font></strong></a><br CLEAR="ALL"/><font size="+1">This object()
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Return an "empty" BeanShell object context which can be used to hold 
	data items.  e.g. 
	<p>
	<pre>
    myStuff = object();
    myStuff.foo = 42;
    myStuff.bar = "blah";
	</pre>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="pathToFile"><strong><font size="+2">pathToFile</font></strong></a><br CLEAR="ALL"/><font size="+1">File pathToFile ( String filename ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Create a File object corresponding to the specified file path name, taking
	into account the bsh current working directory (bsh.cwd)

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="print"><strong><font size="+2">print</font></strong></a><br CLEAR="ALL"/><font size="+1">void print ( arg ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the string value of the argument, which may be of any type.
	If beanshell is running interactively, the output will always go to the 
	command line, otherwise it will go to System.out.
	<p>

	Most often the printed value of an object will simply be the Java 
	toString() of the object.  However if the argument is an array the contents 
	of the array will be (recursively) listed in a verbose way.
	<p>

	Note that you are always free to use System.out.println() 
	instead of print().

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="printBanner"><strong><font size="+2">printBanner</font></strong></a><br CLEAR="ALL"/><font size="+1">printBanner ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the BeanShell banner (version and author line) - GUI or non GUI.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="pwd"><strong><font size="+2">pwd</font></strong></a><br CLEAR="ALL"/><font size="+1">pwd ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the BeanShell working directory.  This is the cwd obeyed by all the 
	unix-like bsh commands.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="reloadClasses"><strong><font size="+2">reloadClasses</font></strong></a><br CLEAR="ALL"/><font size="+1">void reloadClasses( [ package name ] )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Reload the specified class, package name, or all classes if no name is 
	given.  e.g.
	<p>

	<pre>
    reloadClasses();
    reloadClasses("mypackage.*");
    reloadClasses(".*")  // reload unpackaged classes
    reloadClasses("mypackage.MyClass") 
	</pre>
	<p>

	See "Class Path Management"
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="rm"><strong><font size="+2">rm</font></strong></a><br CLEAR="ALL"/><font size="+1">boolean rm ( String pathname ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Remove a file (like Unix rm).

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="run"><strong><font size="+2">run</font></strong></a><br CLEAR="ALL"/><font size="+1">run ( String filename , Object runArgument ) <br CLEAR="ALL"/>run ( String filename ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Run a command in its own in its own private global namespace, with its
	own class manager and interpeter context.  (kind of like unix "chroot" for 
	a namespace).
	The root bsh system object is extended (with the extend() command) and 
	made visible here, so that general system info (e.g. current working
	directory) is effectively inherited.  Because the root bsh object is 
	extended it is effectively read only / copy on write...  
	e.g. you can change directories in the child context, do imports, change
	the classpath, etc. and it will not affect the calling context.
	<p>

	run() is like source() except that it runs the command in a new, 
	subordinate and prune()'d namespace.  So it's like "running" a command 
	instead of "sourcing" it.  run() teturns the object context in which the 
	command was run.
	<p>

	Returns the object context so that you can gather results.
	<p>
	Parameter runArgument an argument passed to the child context under the
		name runArgument.  e.g. you might pass in the calling This context
		from which to draw variables, etc.
	<p>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="save"><strong><font size="+2">save</font></strong></a><br CLEAR="ALL"/><font size="+1">void save ( Object obj , String filename ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Save a serializable Java object to filename. 

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="server"><strong><font size="+2">server</font></strong></a><br CLEAR="ALL"/><font size="+1">void server ( int port ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Create a remote BeanShell listener service attached to 
	the current interpreter, listening on the specified port.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setAccessibility"><strong><font size="+2">setAccessibility</font></strong></a><br CLEAR="ALL"/><font size="+1">setAccessibility ( boolean b ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Setting accessibility on enables to private and other non-public
	fields and method.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setClassPath"><strong><font size="+2">setClassPath</font></strong></a><br CLEAR="ALL"/><font size="+1">void setClassPath( URL [] )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Change the classpath to the specified array of directories and/or archives.
	<p>
	See "Class Path Management" for details.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setFont"><strong><font size="+2">setFont</font></strong></a><br CLEAR="ALL"/><font size="+1">Font setFont ( Component comp , String family , int style , int size ) <br CLEAR="ALL"/>Font setFont ( Component comp , int size ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Change the point size of the font on the specified component, to ptsize.
	This is just a convenience for playing with GUI components.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setNameCompletion"><strong><font size="+2">setNameCompletion</font></strong></a><br CLEAR="ALL"/><font size="+1">void setNameCompletion ( boolean bool ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Allow users to turn off name completion.
	<p>
	Turn name completion in the GUI console on or off.
	Name competion is on by default.  Explicitly setting it to true however can
	be used to prompt bsh to read the classpath and provide immediate feedback.
	(Otherwise this may happen behind the scenes the first time name completion
	is attempted).  Setting it to false will disable name completion.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setNameSpace"><strong><font size="+2">setNameSpace</font></strong></a><br CLEAR="ALL"/><font size="+1">setNameSpace ( ns ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Set the namespace (context) of the current scope.
	<p/>

	The following example illustrates swapping the current namespace.
	<p/>

	<pre>
    fooState = object(); 
    barState = object(); 
    
    print(this.namespace);
    setNameSpace(fooState.namespace);
    print(this.namespace);
    a=5;
    setNameSpace(barState.namespace);
    print(this.namespace);
    a=6;
    
    setNameSpace(fooState.namespace);
    print(this.namespace);
    print(a);  // 5
    
    setNameSpace(barState.namespace);
    print(this.namespace);
    print(a); // 6
    </pre>
	<p/>

	You could use this to creates the effect of a static namespace for a
	method by explicitly setting the namespace upon entry.
	<p/>

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setStrictJava"><strong><font size="+2">setStrictJava</font></strong></a><br CLEAR="ALL"/><font size="+1">void setStrictJava ( boolean val ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Enable or disable "Strict Java Mode".
	When strict Java mode is enabled BeanShell will:
	<p>

	<ol>
	<li>Require typed variable declarations, method arguments and return types.
	<li>Modify the scoping of variables to look for the variable
	declaration first in the parent namespace, as in a java method inside 
	a java class.  e.g. if you can write a method called incrementFoo() that 
	will do the expected thing without referring to "super.foo".
	</ul>
	<p/>

	See "Strict Java Mode" for more details.
	<p/>

	<em>Note: Currently most standard BeanShell commands will not work in 
	Strict Java mode simply because they have not been written with full
	types, etc.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="show"><strong><font size="+2">show</font></strong></a><br CLEAR="ALL"/><font size="+1">show ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Toggle on or off displaying the results of expressions (off by default).
	When show mode is on bsh will print() the value returned by each expression 
	you type on the command line.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="source"><strong><font size="+2">source</font></strong></a><br CLEAR="ALL"/><font size="+1">Object source ( String filename ) <br CLEAR="ALL"/>Object source ( URL url ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Read filename into the interpreter and evaluate it in the current
	namespace.  Like the Bourne Shell "." command.
	This command acts exactly like the eval() command but reads from a file 
	or URL source.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="sourceRelative"><strong><font size="+2">sourceRelative</font></strong></a><br CLEAR="ALL"/><font size="+1">sourceRelative ( String file ) <br CLEAR="ALL"/></font></td></tr><tr><td>
    Source a file relative to the callering script's directory.
	<p/>

    e.g. scripts A running in dir A sources script B in dir B.
	Script B can use this command to load additional scripts (data, etc.)
	relative to its own location (dir B) without having to explicitly know 
	its "home" directory (B).
	<p/>
	Note: this only works for files currently.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="thinBorder"><strong><font size="+2">thinBorder</font></strong></a><br CLEAR="ALL"/><font size="+1">public thinBorder ( ) <br CLEAR="ALL"/>public thinBorder ( Color lightColor , Color darkColor ) <br CLEAR="ALL"/>public thinBorder ( Color lightColor , Color darkColor , boolean rollOver ) <br CLEAR="ALL"/></font></td></tr><tr><td> 
 * A one pixel wide bevel border.  This border works for buttons (with optional
 * rollover) and other components
 *
 * @author Daniel Leuck
 
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="unset"><strong><font size="+2">unset</font></strong></a><br CLEAR="ALL"/><font size="+1">void unset ( String name ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	"Undefine" the variable specifed by 'name' (So that it tests == void).
	<p>
	<em>Note: there will be a better way to do this in the future.  This is 
	currently equivalent to doing namespace.setVariable(name, null);</em>

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="which"><strong><font size="+2">which</font></strong></a><br CLEAR="ALL"/><font size="+1">which( classIdentifier | string | class )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Use classpath mapping to determine the source of the specified class
	file.  (Like the Unix which command for executables).
	<p/>

    This command maps the entire classpath and prints all of the occurrences
    of the class.  If you just want to find the first occurrence in the
    classpath (the one that will be used by Java) you can also get it by
    printing the URL of the resource. e.g.:
	<p/>

    <pre>
        print( getResource("/com/foo/MyClass.class") );
		// Same as...
        // System.out.println(
        //    getClass().getResourceAsStream("/com/foo/MyClass.class" ) );
    </pre>
	<p/>

	Note: This is all a lie! This command is broken and only reports the
	currently first occurence! To be fixed!
	<p/>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="workspaceEditor"><strong><font size="+2">workspaceEditor</font></strong></a><br CLEAR="ALL"/><font size="+1">workspaceEditor ( Interpreter parent , String name ) <br CLEAR="ALL"/></font></td></tr><tr><td>
 * Make a new workspaceEditor associated with a workspace and place it on the
 * desktop.
 *
 * @method workspaceEditor( bsh.Interpreter parent, String name )
 *
 * @author Pat Niemeyer
 * @author Daniel Leuck
 
</td></tr></table>

<table cellspacing="10"><tr><td align="center"><a href="http://www.beanshell.org/"><img src="../images/homebutton.gif"/><br/>Home</a></td><td><a href="credit.html#Credit_and_Acknowledgments"><img src="../images/backbutton.gif"/><br/>Back
			</a></td><td align="center"><a href="contents.html"><img src="../images/upbutton.gif"/><br/>Contents</a></td><td align="center"><img src="../images/forwardbutton.gif"/><br/>Next
			</td></tr></table></body></html>
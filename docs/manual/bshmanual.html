<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="manual.xsl"?>
<html><head><title>BeanShell User's Manual</title></head><body bgcolor="#ffffff">
	<table border="1" width="100%" height="100%">
<tr><td>
<table width="100%" height="100%">
<tr><td height="70%" align="center">
<font size="+4">BeanShell</font>
<br CLEAR="ALL"/>
<font size="+3"><em>Simple Java Scripting</em></font>
<br CLEAR="ALL"/>
<br CLEAR="ALL"/>
<font size="+0"><em>version 1.3</em></font>
</td></tr><tr><td/></tr>
</table>
</td></tr>
</table>
<!-- PAGE BREAK -->

	<h1><a name="Table_of_Contents">Table of Contents</a></h1>
	
	<ul><li><a href="#Table_of_Contents">Table of Contents</a></li><li><a href="#Introduction">Introduction</a></li><ul><li><a href="#Scripting_vs._Application_Languages">Scripting vs. Application Languages</a></li><li><a href="#Tearing_Down_the_Barriers">Tearing Down the Barriers</a></li><li><a href="#History">History</a></li><li><a href="#Conclusion">Conclusion</a></li></ul><li><a href="#Quick_Start">Quick Start</a></li><ul><li><a href="#Download_and_Run_BeanShell">
Download and Run BeanShell
</a></li><li><a href="#The_BeanShell_GUI">
The BeanShell GUI
</a></li><li><a href="#Java_Statements_and_Expressions">
Java Statements and Expressions
</a></li><li><a href="#Useful_BeanShell_Commands">
Useful BeanShell Commands
</a></li><li><a href="#Scripted_Methods">
Scripted Methods
</a></li><li><a href="#Implementing_Interfaces">Implementing Interfaces</a></li><li><a href="#Scripted_Objects">
Scripted Objects
</a></li><li><a href="#Calling_BeanShell_From_Your_Application">Calling BeanShell From Your Application</a></li><li><a href="#Conclusion">Conclusion</a></li></ul><li><a href="#Basic_Syntax">Basic Syntax</a></li><ul><li><a href="#Standard_Java_Syntax"> Standard Java Syntax </a></li><li><a href="#Loosely_Typed_Java_Syntax">Loosely Typed Java Syntax </a></li><li><a href="#Exception_Handling">Exception Handling</a></li><li><a href="#Basic_Scoping_of_Variables">Basic Scoping of Variables</a></li><li><a href="#Variable_Modifiers">Variable Modifiers</a></li><li><a href="#Convenience_Syntax">Convenience Syntax</a></li><li><a href="#Auto_Boxing_and_Unboxing">Auto Boxing and Unboxing</a></li><li><a href="#Importing_Classes_and_Packages">Importing Classes and Packages</a></li><li><a href="#Document_Friendly_Entities">Document Friendly Entities</a></li></ul><li><a href="#Scripted_Methods">Scripted Methods</a></li><ul><li><a href="#Scoping_of_Variables_and_Methods">Scoping of Variables and Methods</a></li><li><a href="#Scope_Modifier:_'super'">Scope Modifier: 'super'</a></li></ul><li><a href="#Scripted_Objects">Scripted Objects</a></li><ul><li><a href="#The_'this'_reference">The 'this' reference</a></li></ul><li><a href="#Scope_Modifiers">Scope Modifiers</a></li><ul><li><a href="#'this',_'super',_and_'global'">'this', 'super', and 'global'</a></li><li><a href="#Synchronized_Methods_Revisited">Synchronized Methods Revisited</a></li></ul><li><a href="#Scripting_Interfaces">Scripting Interfaces</a></li><ul><li><a href="#Anonymous_Inner-Class_Style">Anonymous Inner-Class Style</a></li><li><a href="#'this'_references_as_Interface_Types">'this' references as Interface Types</a></li><li><a href="#Interface_Types_and_Casting">Interface Types and Casting</a></li><li><a href="#&quot;Dummy&quot;_Adapters_and_Incomplete_Interfaces">"Dummy" Adapters and Incomplete Interfaces</a></li><li><a href="#Threads_-_Scripting_Runnable">Threads - Scripting Runnable</a></li><li><a href="#Limitations">Limitations</a></li></ul><li><a href="#Special_Variables_and_Values">Special Variables and Values</a></li><ul><li><a href="#Special_Members_of_'this'_type_References">Special Members of 'this' type References</a></li><li><a href="#Undefined_Variables">Undefined Variables</a></li><li><a href="#Setting_the_Command_Prompt">Setting the Command Prompt</a></li></ul><li><a href="#BeanShell_Commands">BeanShell Commands</a></li><ul><li><a href="#Commands_Overview">Commands Overview</a></li></ul><li><a href="#Adding_BeanShell_Commands">Adding BeanShell Commands</a></li><ul><li><a href="#Hello_World">Hello World</a></li><li><a href="#Compiled_Commands">Compiled Commands</a></li><li><a href="#User_Defined_Commands_with_invoke()">User Defined Commands with invoke()</a></li><li><a href="#Commands_Scope">Commands Scope</a></li><li><a href="#Getting_the_Caller_Context">Getting the Caller Context</a></li><li><a href="#setNameSpace()">setNameSpace()</a></li><li><a href="#Getting_the_Invocation_Text">Getting the Invocation Text</a></li><li><a href="#Working_with_Dirctories_and_Paths">Working with Dirctories and Paths</a></li><li><a href="#Working_With_Class_Identifiers">Working With Class Identifiers</a></li><li><a href="#Working_with_Iterable_Types">Working with Iterable Types</a></li></ul><li><a href="#Strict_Java_Mode">Strict Java Mode</a></li><li><a href="#Class_Loading_and_Class_Path_Management">Class Loading and Class Path Management</a></li><ul><li><a href="#Changing_the_Class_Path">Changing the Class Path</a></li><li><a href="#Auto-Importing_from_the_Classpath">Auto-Importing from the Classpath</a></li><li><a href="#Reloading_Classes">Reloading Classes</a></li><li><a href="#Loading_Classes_Explicitly">Loading Classes Explicitly</a></li><li><a href="#Setting_the_Default_ClassLoader">Setting the Default ClassLoader</a></li><li><a href="#Class_Loading_in_Java">Class Loading in Java</a></li><li><a href="#Class_Loading_in_BeanShell">Class Loading in BeanShell</a></li></ul><li><a href="#Modes_of_Operation">Modes of Operation</a></li><ul><li><a href="#Standalone">Standalone</a></li><li><a href="#Remote">Remote</a></li><li><a href="#Interactive_Use">Interactive Use</a></li><li><a href="#The_.bshrc_Init_File">The .bshrc Init File</a></li></ul><li><a href="#Embedding_BeanShell_in_Your_Application">Embedding BeanShell in Your Application</a></li><ul><li><a href="#The_BeanShell_Core_Distribution">The BeanShell Core Distribution</a></li><li><a href="#Calling_BeanShell_From_Java">Calling BeanShell From Java</a></li><li><a href="#eval()">eval()</a></li><li><a href="#EvalError">EvalError</a></li><li><a href="#source()">source()</a></li><li><a href="#Multiple_Interpreters_vs._Multi-threading">Multiple Interpreters vs. Multi-threading</a></li><li><a href="#Serializing_Interpreters_and_Scripted_Objects">Serializing Interpreters and Scripted Objects</a></li></ul><li><a href="#Remote_Server_Mode">Remote Server Mode</a></li><ul><li><a href="#Web_Browser_Access">Web Browser Access</a></li><li><a href="#Example">Example</a></li><li><a href="#Telnet_Access">Telnet Access</a></li></ul><li><a href="#BshServlet_and_Servlet_Mode_Scripting">BshServlet and Servlet Mode Scripting</a></li><ul><li><a href="#Deploying_BshServlet">Deploying BshServlet</a></li><li><a href="#Running_Scripts">Running Scripts</a></li><li><a href="#The_Script_Environment">The Script Environment</a></li><li><a href="#BshServlet_Parameters">BshServlet Parameters</a></li></ul><li><a href="#The_BeanShell_Demo_Applet">The BeanShell Demo Applet</a></li><li><a href="#BeanShell_Desktop">BeanShell Desktop</a></li><ul><li><a href="#Shell_Windows">Shell Windows</a></li><li><a href="#Editor_Windows">Editor Windows</a></li><li><a href="#The_Class_Browser">The Class Browser</a></li></ul><li><a href="#BshDoc_-_Javadoc_Style_Documentation">BshDoc - Javadoc Style Documentation</a></li><ul><li><a href="#BshDoc_Comments">BshDoc Comments</a></li><li><a href="#BshDoc_XML_Output">BshDoc XML Output</a></li><li><a href="#The_bshcommands.xsl_stylesheet">The bshcommands.xsl stylesheet</a></li></ul><li><a href="#The_BeanShell_Parser">The BeanShell Parser</a></li><ul><li><a href="#Validating_Scripts_With_bsh.Parser">Validating Scripts With bsh.Parser</a></li><li><a href="#Parsing_and_Performance">Parsing and Performance</a></li><li><a href="#Parsing_Scripts_Procedurally">Parsing Scripts Procedurally</a></li></ul><li><a href="#Using_JConsole">Using JConsole</a></li><ul><li><a href="#ConsoleInterface">ConsoleInterface</a></li></ul><li><a href="#Reflective_Style_Access_to_Scripted_Methods">Reflective Style Access to Scripted Methods</a></li><ul><li><a href="#eval()">eval()</a></li><li><a href="#invokeMethod()">invokeMethod()</a></li><li><a href="#Method_Lookup">Method Lookup</a></li><li><a href="#BshMethod">BshMethod</a></li><li><a href="#Uses">Uses</a></li></ul><li><a href="#Executable_scripts_under_Unix">Executable scripts under Unix</a></li><li><a href="#BSF_Bean_Scripting_Framework">BSF Bean Scripting Framework</a></li><ul><li><a href="#Ant">Ant</a></li></ul><li><a href="#Learning_More">Learning More</a></li><ul><li><a href="#Helping_With_the_Project">Helping With the Project</a></li></ul><li><a href="#Credit_and_Acknowledgments">Credit and Acknowledgments</a></li><ul><li><a href="#License_and_Terms_of_Use">License and Terms of Use</a></li></ul><li><a href="#BeanShell_Commands_Documentation">BeanShell Commands Documentation</a></li></ul> <!-- Auto generated table of contents -->
<hr/><!--PAGE BREAK-->

 <!-- Auto generated table of contents -->
	<h1><a name="Introduction">Introduction</a></h1>


This document is about BeanShell. 
BeanShell is a small, free, embeddable Java source interpreter with 
object scripting language features, written in Java.  BeanShell executes 
standard Java statements and expressions but also extends Java into the 
scripting domain with common scripting language conventions and syntax.
BeanShell is a <em>natural</em> scripting language for Java.
<p CLEAR="ALL"/>

<h2><a name="Scripting_vs._Application_Languages">Scripting vs. Application Languages</a></h2>

Traditionally, the primary difference between a scripting language and 
a compiled language has been in its type system: the way in which you define 
and use data elements.  You might be thinking that there is a more obvious 
difference here - that of "interpreted" code vs. compiled code.  But 
the compiler in and of itself does not fundamentally change the way you work 
with a language.  Nor does interpreting a language necessarily make 
it more useful for what we think of as "scripting".
It is the type system of a language that makes it possible for a compiler 
to analyze the structure of an application for correctness.
Without types, compilation is reduced to just a grammar check and an 
optimization for speed.
From the developer's perspective, it is also the type system that 
characterizes the way in which we interact with the code.
<p CLEAR="ALL"/>

Types are good.  Without strongly type languages it would be very hard to
write large scale systems and make any assertions about their correctness
before they are run.  But working with types imposes a burden on the developer.
Types are labels and labeling things can be tedious.  It can be especially 
tedious during certain kinds of development or special applications where 
it is flexibility and not program structure that is paramount.  
There are times where simplicity and ease of use is a more important 
criterion.  
<p CLEAR="ALL"/>

This is not just rationalization to cover some underlying laziness.  
Productivity affects
what people do and more importantly do *not* do in the real world, much more
than you might think.  There is a lot of important software that exists in 
the world today only because the cost/benefit ratio in some developer's mind 
reached a certain threshold.  
<p CLEAR="ALL"/>

Unit testing - one of the foundations of 
writing good code - is a prime example.  Unit tests for well written code are, 
in general, vitally important as a collective but almost insignificant 
individually.  It's a "tragedy of the commons" that leads individual
developers to repeatedly weigh the importance of writing another unit test
with working on "real code".
Give developers have a tool that makes it easy to perform a test with a line or
two of code they will probably use it.  If, moreover, it is also a tool that
they enjoy using during their development process - that saves the time, they
will be even more inclined to use it.   
<p CLEAR="ALL"/>

Customizability through scripting also opens the door to applications that 
are more powerful than the sum of their parts.  When users can extend, enhance,
and add to their applications they use them in new and unexpected ways.
<p CLEAR="ALL"/>

Scripting is powerful.
<p CLEAR="ALL"/>


<h2><a name="Tearing_Down_the_Barriers">Tearing Down the Barriers</a></h2>

Traditionally scripting languages have traded
in the power of types for simplicity.  Most scripting languages distill the 
type system to just one or a handful of types such as strings, numbers, or 
simple lists.  This is sufficient for many kinds of scripting.  
<p CLEAR="ALL"/>

Many scripting languages operate in a loose, unstructured land - a place 
dominated by text and course-grained tools.  
As such these scripting languages have evolved
sophisticated mechanisms for working with these simple types (regular
expressions, pipes, etc.). 
As a result there has developed a casm between the scripting languages 
and the application languages created by the collapse of the type system 
in-between.
The scripting languages have remained a separate species, isolated and 
speaking a different dialect from their brothers the application languages.  
<p CLEAR="ALL"/>

BeanShell is a new kind of scripting language.  BeanShell begins with 
the standard Java language and bridges it into the scripting domain in a 
natural way, but allowing the developer to relaxing types where appropriate.
It is possible to write BeanShell scripts that look exactly like Java 
method code.  But it's also possible to write scripts that look more like
a traditional scripting language, while still maintaining the framework
of the Java syntax.
<p CLEAR="ALL"/>

BeanShell emulates typed variables and parameters when they are used.  This 
allows you to "seed" your code with strong types where appropriate.  You can 
"shore up" repeatedly used methods as you work on them, migrating them 
closer to Java.  Eventually you may find that you want to compile
these methods and maintain them in standard Java.  With BeanShell this is
easy.  BeanShell does not impose a syntactic boundary between your 
scripts and Java.
<p CLEAR="ALL"/>

But the bridge to Java extends much deeper than simple code similarity.  
BeanShell is one of a new breed of scripting languages made possible by
Java's advanced reflection capabilities.  Since BeanShell can run in the same
Java virtual machine as your application, you can freely work with real,
live, Java objects - passing them into and out of your scripts.  Combined
with BeanShell's ability to implement Java interfaces, you can achieve 
seamless and simple integration of scripting into your Java applications.
BeanShell does not impose a type boundary between your scripts and Java.
<p CLEAR="ALL"/>

<h2><a name="History">History</a></h2>

What seems like an eternity ago, back in the summer of 1993, I was working at
Southwestern Bell Technology Resources and I was infatuated with the Tcl/Tk 
scripting language. 
On the advice of someone at Sun I also began playing around a bit with the 
Oak language written by James Gosling.
Little did I know that within just a few years Oak, which would become Java,
would not only spark a revolution, but that I would be writing one of the 
first books on the new Java language (Exploring Java, 
O'Reilly &amp; Associates) and creating 
Java's first scripting language, BeanShell, drawing inspiration from Tcl.
<p CLEAR="ALL"/>

BeanShell's first public release was not until 1997, but I had been
poking at it in one form or another for some time before that. BeanShell 
as a language became practical when Sun added reflection to the Java language 
in version 1.1.  After that, and after having seen its value in helping me 
create examples and snippets for the second edition of my book, I decided to
try to polish it up and release it.
<p CLEAR="ALL"/>

BeanShell has slowly, but steadily gained popularity since then.  It has
grown in fits and spurts as its contributor's time has allowed.  But recently
BeanShell has achieved a sort of critical mass.  BeanShell is distributed with
Emacs as part of the JDE and with Sun Microsystem's NetBeans / Forte for Java
IDEs.  BeanShell is also bundled by BEA with their Weblogic application 
server.  We've had reports of BeanShell being used everywhere from 
the high energy physics laboratory CERN, to classrooms teaching programming
to nine year olds.  BeanShell is being used in everything from large 
financial applications all the way down to embedded systems floating in Buoys 
in the pacific ocean.   I attribute this success to the power of the open 
source development model and owe many thanks to everyone who has contributed.
<p CLEAR="ALL"/>

<h2><a name="Conclusion">Conclusion</a></h2>

I believe that BeanShell is the simplest and most natural scripting language 
for Java because it is, foremost, Java.  BeanShell draws on a 
rich history of scripting languages for its scripting syntax and uses it to
very conservatively extend the Java language into this new domain.
I hope that you have half as much fun using BeanShell as I have had working
on it and I welcome all comments and suggestions.
<p CLEAR="ALL"/>


<hr/><!--PAGE BREAK-->

	<h1><a name="Quick_Start">Quick Start</a></h1>


Welcome to BeanShell.
This is a crash course to get you going.  We'll leave out many
important options and details.  Please see the rest of the user's guide 
for more information.
<p CLEAR="ALL"/>

<h2><a name="Download_and_Run_BeanShell">
Download and Run BeanShell
</a></h2>

Download the latest JAR file from http://www.beanshell.org
and start up BeanShell either in the graphical desktop mode or on 
the command line.
<p CLEAR="ALL"/>

If you just want to start playing around you may be able to launch the 
BeanShell desktop by simply double clicking on the BeanShell JAR file.  More 
generally however you'll want to add the jar to your classpath so that you 
can work with your own classes and applications easily.
<p CLEAR="ALL"/>

To do this you can either drop the BeanShell JAR file into your Java 
extensions folder or add it to your classpath.  (Important: If you put 
BeanShell in the extensions folder and wish to use it with BSF applications 
like Jakarta Ant you must install the bsf.jar in the same location).

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
To install as an extension place the bsh.jar file in your 
$JAVA_HOME/jre/lib/ext folder.  (OSX users: place the bsh.jar in 
/Library/Java/Extensions or ~/Library/Java/Extensions for individual users.)

Or add BeanShell to your classpath like this:

unix:     export CLASSPATH=$CLASSPATH:bsh-xx.jar
windows:  set classpath=%classpath%;bsh-xx.jar
</pre></td></tr></table></center><p/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can modify the classpath from within BeanShell using the addClassPath()
and setClassPath() commands.
</td></tr></table></center><p/>

You can then run BeanShell in either a GUI or command line mode:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
    java bsh.Console       // run the graphical desktop
or
    java bsh.Interpreter   // run as text-only on the command line
or
    java bsh.Interpreter filename [ args ] // run script file
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

It's also possible to call BeanShell from within your own Java applications,
to reach it in a remote server mode for debugging, to use it as a servlet, 
or even in an applet.  See "BeanShell Modes of Operation" for more details.

<h2><a name="The_BeanShell_GUI">
The BeanShell GUI
</a></h2>

The BeanShell GUI desktop is meant to allow some experimentation with the
features of BeanShell.  It is not intended to be a replacement for a full
featured IDE.  Please check out the 
<a href="http://www.jedit.org/">jEdit editor</a> for an example of a full
featured development environment based in part on BeanShell scripting
capabilities.
<p CLEAR="ALL"/>

Upon starting the BeanShell in GUI mode a console window will open.  
By right clicking on the desktop background you can open additional 
console windows and other tools such as a simple class browser.
<p CLEAR="ALL"/>

Each console window runs a separate instance of the BeanShell interpreter.
The graphical console supports basic command history, line editing,
cut and paste, and even class and variable name completion.  From the console 
you can open a simple editor window.  In it you can write 
scripts and use the 'eval' option to evaluate the text in the attached 
console's workspace or a new workspace.
<p CLEAR="ALL"/>

<h2><a name="Java_Statements_and_Expressions">
Java Statements and Expressions
</a></h2>

BeanShell understands standard Java statements, expressions, and 
method declarations.
Statements and expressions are all of the normal things that you'd say
inside a Java method such as variable declarations and assignments, 
method calls, loops, and conditionals.
<p CLEAR="ALL"/>

You can use these exactly as they would appear in Java,
however in BeanShell you also have the option of working with "loosely typed"
variables.  That is, you can simply omit the types of variables that you use 
(both primitives and objects).  BeanShell will only
signal an error if you attempt to misuse the actual type of the variable.
<p CLEAR="ALL"/>

Here are some examples:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo = "Foo";    
four = (2 + 2)*2/2;
print( foo + " = " + four );  // print() is a BeanShell command

// Do a loop
for (i=0; i&lt;5; i++)
    print(i);   

// Pop up a frame with a button in it
button = new JButton( "My Button" );
frame = new JFrame( "My Frame" );
frame.getContentPane().add( button, "Center" );
frame.pack();
frame.setVisible(true);
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

<h2><a name="Useful_BeanShell_Commands">
Useful BeanShell Commands
</a></h2>

In the previous example we used a convenient "built-in" BeanShell command 
called print(), to display values.  print() does pretty
much the same thing as System.out.println() except that it insures that the
output always goes to the command line.  print() also displays some types
of objects (such as arrays) more verbosely than Java would.  

Another related command is show(), which toggles on and off automatic 
display of the result of every line you type.
<p CLEAR="ALL"/>

Here are a few other examples of BeanShell commands:

<ul>
<li> <strong>source(), run()</strong>  
- Read a bsh script into this interpreter, or run it
in a new interpreter</li>

<li> <strong>frame()</strong>  
- Display a GUI component in a Frame or JFrame.</li>

<li> <strong>load(),  save()</strong> 
- Load or save serializable objects to a file.</li>

<li> <strong>cd(), cat(), dir(), pwd(), etc.</strong>  
- Unix-like shell commands</li>

<li> <strong>exec()</strong> - Run a native application </li>

<li><strong>javap()</strong> - Print the methods and fields of an object,
similar to the output of the Java javap command.</li>

<li> <strong>setAccessibility()</strong> 
- Turn on unrestricted access to private and protected components.</li>

</ul>

<p CLEAR="ALL"/>
See the complete list of <a href="bshcommands.html">BeanShell Commands</a>
for more information.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
BeanShell commands are not really "built-in" but are simply BeanShell scripts
that are automatically loaded from the classpath.  You can add your 
own scripts to the classpath to extend the basic command set.
</td></tr></table></center><p/>

<h2><a name="Scripted_Methods">
Scripted Methods
</a></h2>

You can declare and use methods in BeanShell just as you would in a Java class.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
int addTwoNumbers( int a, int b ) {
    return a + b;
}

sum = addTwoNumbers( 5, 7 );  // 12
</pre></td></tr></table></center><p/>


Bsh methods may also allow dynamic (loose) argument and return types.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
add( a, b ) {
    return a + b;
}

foo = add(1, 2);            // 3
foo = add("Oh", " baby");   // "Oh baby"
</pre></td></tr></table></center><p/>

<h2><a name="Implementing_Interfaces">Implementing Interfaces</a></h2>

<em>Note: implementing arbitrary interfaces requires BeanShell be run
under a Java 1.3 or higher environment.</em>
<p CLEAR="ALL"/>

You can use the standard Java anonymous inner class syntax to implement an
interface type with a script.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
ActionListener scriptedListener = new ActionListener() {
    actionPerformed( event ) { ... }
}
</pre></td></tr></table></center><p/>

You don't have to script all of the methods of an interface.  You can opt to
script only those that you intend to call if you want to.  
The calling code will simply throw an exception if it tries to 
invoke a method that isn't defined.
If you wish to override the behavior of a large number of methods - say to
produce a "dummy" adapter for logging - you can implement a special method
signature: invoke(name, args) in your scripted object. The invoke() method
is called to handle any undefined method invocations:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
ml = new MouseListener() {
    mousePressed( event ) { ... }
    // handle the rest
    invoke( name, args ) { print("Method: "+name+" invoked!");
}
</pre></td></tr></table></center><p/>

<h2><a name="Scripted_Objects">
Scripted Objects
</a></h2>

In BeanShell, as in JavaScript and Perl, method "closures" allow you to create
scripted objects.  You can turn the results of a method call into an object
reference by having the method return the special value <strong>this</strong>.
You can then use the reference to refer to any variables set during the method 
call.  Useful objects need methods of course, so in BeanShell scripted methods 
may also contain methods at any level.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    print("foo");
    x=5;

    bar() {
        print("bar");
    }

    return this;
}

myfoo = foo();    // prints "foo"
print( myfoo.x ); // prints "5"
myfoo.bar();      // prints "bar"
</pre></td></tr></table></center><p/>

If this "closure" thing seems strange to don't worry.  It's just an 
evolutionary step that languages acquired along the path to Objects.
Please see the user's manual for a more thorough explanation.
<p CLEAR="ALL"/>

Within your scripts, BeanShell scripted objects 
(i.e. any <em>'this'</em> type reference like myFoo in the previous example) 
can automatically implement any Java interface type.  When Java code calls 
methods on the interface the corresponding scripted methods will be invoked to 
handle them.  BeanShell will automatically "cast" your scripted object 
when you attempt to pass it as an argument to a method that takes an interface
type.
For passing script references outside of BeanShell, you can perform an 
explicit cast where necessary.  Please see the user manual for full details.
<p CLEAR="ALL"/>

<h2><a name="Calling_BeanShell_From_Your_Application">Calling BeanShell From Your Application</a></h2>

You can evaluate text and run scripts from within your application by
creating an instance of the BeanShell interpreter and using the eval()
or source() commands.  You may pass in variable references to objects you 
wish to use in scripts via the set() method and retrieve results with the 
get() method.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import bsh.Interpreter;

Interpreter i = new Interpreter();  // Construct an interpreter
i.set("foo", 5);                    // Set variables
i.set("date", new Date() ); 

Date date = (Date)i.get("date");    // retrieve a variable

// Eval a statement and get the result
i.eval("bar = foo*10");             
System.out.println( i.get("bar") );

// Source an external script file
i.source("somefile.bsh");
</pre></td></tr></table></center><p/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>In the above example the Interpreter's eval() method also returned the 
value of bar as the result of the evaluation.</td></tr></table></center><p/>

<h2><a name="Conclusion">Conclusion</a></h2>

We hope this brief introduction gets you started.  Please see the full user
manual for more details.  Please consult the mailing list archives for
more useful information.  http://www.beanshell.org/

<hr/><!--PAGE BREAK-->


	<h1><a name="Basic_Syntax">Basic Syntax</a></h1>


BeanShell is, foremost, a Java interpreter. So you probably already know 
most of what you need to start scripting with BeanShell.  This 
section describes specifically what portion of the Java language BeanShell 
interprets and how BeanShell extends it or "loosens" it to be more 
scripting-language-like.
<p CLEAR="ALL"/>

<h2><a name="Standard_Java_Syntax"> Standard Java Syntax </a></h2>

In a BeanShell script (and on the command line) you can type normal 
Java statements and expressions and display the results.  
Statements and expressions are the kinds of things you normally find 
inside of a Java method: variable assignments, method calls, math 
expressions, for-loops, etc.  

<p CLEAR="ALL"/>

Here are some examples:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
/*
    Standard Java syntax
*/

// Use a hashtable
Hashtable hashtable = new Hashtable();
Date date = new Date();
hashtable.put( "today", date );

// Print the current clock value
print( System.currentTimeMillis() );

// Loop
for (int i=0; i&lt;5; i++)
    print(i);

// Pop up a frame with a button in it
JButton button = new JButton( "My Button" );
JFrame frame = new JFrame( "My Frame" );
frame.getContentPane().add( button, "Center" );
frame.pack();
frame.setVisible(true);
</pre></td></tr></table></center><p/>

You can also define your own methods and use them just as you would inside a 
Java class.  We'll get to that in a moment.

<h2><a name="Loosely_Typed_Java_Syntax">Loosely Typed Java Syntax </a></h2>

In the examples above, all of our variables have declared types. e.g. 
"JButton button".  Beanshell will enforce these types, as you will see if 
you later try to assign something other than a JButton to the variable 
"button" (you will get an error message).
However BeanShell also supports "loose" or dynamically typed variables.
That is, you can refer to 
variables without declaring them first and without specifying any type.
In this case BeanShell will do type checking where appropriate at runtime.  
So, for example, we could have left off the types in the above example and 
written all of the above as:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
/*
    Loosely Typed Java syntax
*/

// Use a hashtable
hashtable = new Hashtable();
date = new Date();
hashtable.put( "today", date );

// Print the current clock value
print( System.currentTimeMillis() );

// Loop
for (i=0; i&lt;5; i++)
    print(i);

// Pop up a frame with a button in it
button = new JButton( "My Button" );
frame = new JFrame( "My Frame" );
frame.getContentPane().add( button, "Center" );
frame.pack();
frame.setVisible(true);
</pre></td></tr></table></center><p/>

This may not seem like it has saved us a great deal of work.  But you will
see the difference when you come to rely on scripting as part of your
development and testing process; especially for in interactive use.
<p CLEAR="ALL"/>

When a "loose" variable is used you are free to reassign it to another type of 
Java object later.  Untyped BeanShell variables can also freely hold Java 
primitive values like <b>int</b>
and <b>boolean</b>.  Don't worry, BeanShell always knows the real types and 
only lets you use the values where appropriate.  For primitive types this 
includes doing the
correct numeric promotion that the real Java language would do when you use
them in an expression.
<p CLEAR="ALL"/>

<h2><a name="Exception_Handling">Exception Handling</a></h2>

Exception handling using try/catch blocks works just as it does in Java.  
For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
try {
    int i = 1/0;
} catch ( ArithmeticException e ) {
    print( e );
}
</pre></td></tr></table></center><p/>

But you can loosely type your catch blocks if you wish:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
try {
    ...
} catch ( e ) { 
    print( "caught exception: "+e );
}
</pre></td></tr></table></center><p/>

<h2><a name="Basic_Scoping_of_Variables">Basic Scoping of Variables</a></h2>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
As of BeanShell version 1.3 the default scoping of loosely typed variables was
changed to be more consistent with Java.  BeanShell still supports an alternate
scoping used in earlier versions.  This mode can be enabled for legacy code by 
setting the system property "localscoping" to true.  
See appendix "Local Scoping".
</td></tr></table></center><p/>

Variable scoping in BeanShell behaves, wherever possible, just like that in 
Java.  Ordinary Java, however, does not offer "loose" variables 
(variables that can be used without being declared first).  
So we must define their behavior within BeanShell.
We'll see in the next section that untyped variables - variables that are not 
declared and not assigned a value elsewhere - default to the 
<em>local</em> scope.  
This means that, in general, if you assign a value to a variable without first
declaring it, you are creating a new local variable in the current scope.
<p CLEAR="ALL"/>

<h3>Blocks</h3>

Blocks are statements between curly braces {}.  In BeanShell, as in Java, 
blocks define a level of scope for typed variables: typed variables declared
within a block are local to the block.  Other assignments within the block 
occur, as always, wherever the variable was defined.
<p CLEAR="ALL"/>

Untyped variables in BeanShell, however, are not constrained by blocks.
Instead they act as if they were declared at the outer (enclosing)
scope's level.  
With this in mind, BeanShell code looks just like Java code.

In BeanShell if you declare a typed variable within a block it is local to the
block.  But if you use an untyped variable (which looks just like an ordinary
assignment in Java) it behaves as an assignment to the enclosing scope.
<p CLEAR="ALL"/>

This will make sense with a few examples:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Arbitrary code block
{
    y = 2;      // Untyped variable assigned
    int x = 1;  // Typed variable assigned
}
print( y ); // 2
print( x ); // Error! x is undefined.

// Same with any block statement: if, while, try/catch, etc.
if ( true ) {
    y = 2;      // Untyped variable assigned
    int x = 1;  // Typed variable assigned
}
print( y ); // 2
print( x ); // Error! x is undefined.
</pre></td></tr></table></center><p/>

Variables declared in the for-init area of a for-loop follow the same
rules as part of the block:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
for( int i=0; i&lt;10; i++ ) {  // typed for-init variable
    j=42;
}
print( i ); // Error! 'i' is undefined.
print( j ); // 42

for( z=0; z&lt;10; z++ ) { }   // untyped for-init variable
print( z ); // 10
</pre></td></tr></table></center><p/>

<h2><a name="Variable_Modifiers">Variable Modifiers</a></h2>

The standard Java variable modifiers may be used on typed variables:
private / protected / public, final, transient, volatile, static.
Only 'final' is currently implemented.  The others are currently ignored.
<p CLEAR="ALL"/>
Modifiers may not be applied to untyped variables.

<h2><a name="Convenience_Syntax">Convenience Syntax</a></h2>

In BeanShell you may access JavaBean properties as if they were fields:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
button = new java.awt.Button();
button.label = "my button";  // Equivalent to: b.setLabel("my button");
print( button.label );       // Equivalent to print( b.getLabel() );
</pre></td></tr></table></center><p/>

JavaBean properties are simply pairs of "setter" and "getter" methods that
adhere to a naming convention.  In the above example BeanShell located
a "setter" method with the name "setLabel()" and used it to assign the string
value.  It then found the method named getLabel() to retrieve the value.
<p CLEAR="ALL"/>

Boolean properties may optionally use the syntax "is" for their "getter".
e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
Float f = new Float(42f);
print( f.infinite );  // Equivalent to print( f.isInfinite() ); // false
</pre></td></tr></table></center><p/>

If there is any ambiguity with an actual Java field name of the object 
(e.g. label in the above example) then the actual field name takes precedence.

If you wish to avoid any ambiguity BeanShell provides an additional, 
uniform syntax for accessing both Java Bean properties and Hashtable or Map 
entries.  You may use the "{}" curly brace construct with a 
String identifier as a qualifier on any variable of the appropriate type:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
b = new java.awt.Button();
b{"label"} = "my button";  // Equivalent to: b.setLabel("my button");

h = new Hashtable();
h{"foo"} = "bar";          // Equivalent to: h.put("foo", "bar");
</pre></td></tr></table></center><p/>

Where the java.util.Collections API is available, Maps are also supported.
<p CLEAR="ALL"/>

<h3>Enhanced 'for' Loop</h3>

BeanShell supports the Java 1.5 style enhanced for-loop for iterating over
collections and array types.  (Note that you do not have to be running Java 1.5
to use this feature).

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
List foo = getSomeList();

for ( untypedElement : foo ) 
	print( untypedElement ); 

for ( Object typedElement: foo ) 
	print( typedElement );

int [] array = new int [] { 1, 2, 3 };

for( i : array ) 
	print(i);

for( char c : "a string" )
	print( c ); 
</pre></td></tr></table></center><p/>

Supported iterable types include all the obvious things.  

<ul>
<li>JDK 1.1+ - (no collections): Enumeration, arrays, Vector, String, StringBuffer</li>
<li>JDK 1.2+ - (w/collections): Collections, Iterator</li>
</ul>

See also the BshIterator API which supports the ehanced for-loop and allows
iteration over these types using the dynamically loaded BeanShell Collection 
manager.
<p CLEAR="ALL"/>

<h3>Switch Statements</h3>

In BeanShell, the switch statement may be used not only with numeric types
but with objects.  For example, you may switch on Dates and Strings which
are compared for equality with their equals() methods:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
dateobj = new Date();

switch( dateobj ) 
{
	case newYears:
		break;
	case christmas:
		break;
	default:
}
</pre></td></tr></table></center><p/>


<h2><a name="Auto_Boxing_and_Unboxing">Auto Boxing and Unboxing</a></h2>

"Boxing" and "Unboxing" are the terms used to describe automatically wrapping 
a primitive type in a wrapper class and unwrapping it as necessary.  Boxing
is a feature of Java (SDK1.5) and has been supported in BeanShell for many
years.
<p CLEAR="ALL"/>

BeanShell supports boxing and unboxing of primitive types.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
int i=5;
Integer iw = new Integer(5);
print( i * iw );  // 25

Vector v = new Vector();
v.put(1); 
int x = v.getFirstElement();
</pre></td></tr></table></center><p/>

<h2><a name="Importing_Classes_and_Packages">Importing Classes and Packages</a></h2>

In BeanShell as in Java, you can either refer to classes by their fully
qualified names, or you can <strong>import</strong> one or more classes 
from a Java package.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Standard Java
import javax.xml.parsers.*;
import mypackage.MyClass;
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

In BeanShell import statements may appear anywhere, even inside a method, 
not just at the top of a file.  In the event of a conflict, later imports take
precedence over earlier ones.
<p CLEAR="ALL"/>

A somewhat experimental feature is the "super import".  With it you may 
automatically import the entire classpath, like so:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import *;
</pre></td></tr></table></center><p/>

The first time you do this BeanShell will map out your entire classpath;
so this is primarily intended for interactive use.  Note that importing every
class in your classpath can be time consuming.  It can also result in a lot 
of ambiguities.  Currently BeanShell will report an error when resolving an 
an ambiguous import from mapping the entire classpath.  You may disambiguate 
it by importing the class you intend.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The BeanShell which() command will use the classpath mapping capability to
tell you where exactly in your classpath a specified class is located:
<pre>
bsh % which( java.lang.String );
Jar: file:/usr/java/j2sdk1.4.0/jre/lib/rt.jar
</pre>
</td></tr></table></center><p/>

See "Class Path Management" for information about modifying the BeanShell
classpath at run-time with the addClassPath() or setClassPath() commands.
<p CLEAR="ALL"/>
Also see "BeanShell Commands" for information about importing new BeanShell
commands from the classpath.
<p CLEAR="ALL"/>

<h3>Default Imports</h3>

By default, common Java core and extension packages are imported for 
you.  They are, in the order in which they are imported:

<ul>
<li>javax.swing.event</li>
<li>javax.swing</li>
<li>java.awt.event</li>
<li>java.awt</li>
<li>java.net</li>
<li>java.util</li>
<li>java.io</li>
<li>java.lang</li>
</ul>
<p CLEAR="ALL"/>

Two BeanShell package classes are also imported by default:
<p CLEAR="ALL"/>

<ul>
<li>bsh.EvalError</li>
<li>bsh.Interpreter</li>
</ul>
<p CLEAR="ALL"/>

Finally, we should mention that BeanShell commands may be imported from the 
classpath.  The default commands are imported in the following way:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
importCommands("/bsh/commands");
</pre></td></tr></table></center><p/>

We will discuss how to import your own commands in a later section.

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The classes java.awt.List and java.util.List are both imported by default.  
Because java.util.List is imported later, as part of the java.util package,
it takes precedence.  To access java.awt.List simply import it in, or the
java.awt package again your script.  Later imports take precedence.
</td></tr></table></center><p/>

<h2><a name="Document_Friendly_Entities">Document Friendly Entities</a></h2>

BeanShell supports special overloaded text forms of all common operators
to make it easier to embed BeanShell scripts inside other kinds of documents
(e.g XML).
<p CLEAR="ALL"/>

<table border="1" cellpadding="5">
<tr><td><strong>@gt</strong></td><td>&gt;</td></tr>
<tr><td><strong>@lt</strong></td><td>&lt;</td></tr>
<tr><td><strong>@lteq</strong></td><td>&lt;=</td></tr>
<tr><td><strong>@gteq</strong></td><td>&gt;=</td></tr>
<tr><td><strong>@or</strong></td><td>||</td></tr>
<tr><td><strong>@and</strong></td><td>&amp;&amp;</td></tr>
<tr><td><strong>@bitwise_and</strong></td><td>&amp;</td></tr>
<tr><td><strong>@bitwise_or</strong></td><td>|</td></tr>
<tr><td><strong>@left_shift</strong></td><td>&lt;&lt;</td></tr>
<tr><td><strong>@right_shift</strong></td><td>&gt;&gt;</td></tr>
<tr><td><strong>@right_unsigned_shift</strong></td><td>&gt;&gt;&gt;</td></tr>
<tr><td><strong>@and_assign</strong></td><td>&amp;=</td></tr>
<tr><td><strong>@or_assign</strong></td><td>|=</td></tr>
<tr><td><strong>@left_shift_assign</strong></td><td>&lt;&lt;=</td></tr>
<tr><td><strong>@right_shift_assign</strong></td><td>&gt;&gt;=</td></tr>
<tr><td><strong>@right_unsigned_shift_assign</strong></td><td>&gt;&gt;&gt;=</td></tr>
</table>

<hr/><!--PAGE BREAK-->

	<h1><a name="Scripted_Methods">Scripted Methods</a></h1>


You can define define methods in BeanShell, just as they would appear in Java:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
int addTwoNumbers( int a, int b ) {
    return a + b;
}
</pre></td></tr></table></center><p/>

And you can use them in your scripts just as you would any Java method or
"built-in" BeanShell command:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
sum = addTwoNumbers( 5, 7 );
</pre></td></tr></table></center><p/>

Just as BeanShell variables may be dynamically typed, methods may have 
dynamic argument and return types.  We could, for example, have declared
our add() method above like so:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
add( a, b ) {
    return a + b;
}
</pre></td></tr></table></center><p/>

In this case, BeanShell would dynamically determine the types when the method is
called and attempt to "do the right thing":

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo = add(1, 2);
print( foo ); // 3

foo = add("Oh", " baby");
print( foo ); // Oh baby
</pre></td></tr></table></center><p/>

In the first case Java performed arithmetic addition on the integers 1 and 2.
(By the way, if we had passed in numbers of other types BeanShell would have 
performed the appropriate numeric promotion and returned the correct Java 
primitive type.)  
In the second
case BeanShell performed the usual string concatenation for String types and
returned a String object.  This example is a bit extreme, as there are no
other overloaded operators like string concatenation in Java.  But it serves 
to emphasize that BeanShell methods can work with loose types.
<p CLEAR="ALL"/>

Methods with unspecified return types may return any type of object (as in
the previous example).
Alternatively they may also simply issue a "return;" without a value, in
which case the effective type of the method is "void" (no type).  In 
either case, the return statement is optional.  If the method does not 
perform an explicit "return" statement and the return type is not explicitly
set to void, the value of the last statement or expression in the method body 
becomes the return value (and must adhere to any declared return typing).
<p CLEAR="ALL"/>

<h3>Method Modifiers and 'throws' Clauses</h3>

The standard Java modifiers may be applied to methods:
private / protected / public, synchronized, final, native, abstract, and 
static.  
<p CLEAR="ALL"/>

The synchronized modifier is the only modifier currently implemented.  The
others are ignored.  The 'throws' clause of methods is checked for valid 
class type names, but is not otherwise enforced.
<p CLEAR="ALL"/>

Synchronized methods are synchronized on the object representing the method's 
common parent scope, so they behave like Java methods contained in a class.
We will return to this topic after discussing scripted objects and "closures".

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// foo() and bar() are synchronized as if they were in a common class
synchronized foo() { }
synchronized bar() { }
</pre></td></tr></table></center><p/>

<h2><a name="Scoping_of_Variables_and_Methods">Scoping of Variables and Methods</a></h2>

As in Java, a method can refer to the values of variables and method names 
from the enclosing scope (in Java the "enclosing scope" would be a class).  
For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
a = 1;
anotherMethod() { ... }

foo() {
    print( a );
	a = a+1;
	anotherMethod();
}

// invoke foo()
foo();      // prints 1
print( a ); // prints 2
</pre></td></tr></table></center><p/>

Variables and methods are "inherited" from the parent scope in the usual way.
In the example above there are just two levels of scope: the top or "global"
scope and the scope of the method foo().  Later we'll talk about scripting
objects in BeanShell and see that there can be arbitrary levels of scoping
involved.  But the rules will be the same.
<p CLEAR="ALL"/>

As in Java, a typed variable is not visible outside the scope in which it is 
declared.  So declaring a variable with a type is a way to limit its scope or
make a <em>local</em> variable.  In BeanShell using an untyped or 
"loosely" typed variable is also equivalent to declaring a local
variable.  That is, if you use a variable that has not been defined elsewhere,
it defaults to the local scope:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
a = 1;

foo() {
	a = a + 1; // a is defined in parent scope
	b = 3;     // undefined, defaults local scope
	int c = 4; // declared local scope
}

// invoke foo()
print( a ); // prints 2
print( b ); // ERROR! b undefined
print( c ); // ERROR! c undefined
</pre></td></tr></table></center><p/>

In the above example the variable 'a' is declared in the global
scope.  When its value is read and assigned inside of foo() the global value 
of 'a' will be affected.  
<p CLEAR="ALL"/>

The variable 'b' is a usage of an untyped variable.  Since 'b' has not been
declared or assigned a value in any enclosing scope, it becomes a local
variable 'b' in the scope of foo.  The variable 'c' is explicitly declared
(with a type) in the scope of foo() and is therefore, of course, local to 
foo().
<p CLEAR="ALL"/>

Later we'll see that BeanShell allows arbitrary nesting of methods.  If we were
to declare another method inside of foo() it could see all of these
variables (a, b, and c) as it is also in the scope of foo().
<p CLEAR="ALL"/>

<h3>Scoping of Loosely Typed Variables</h3>

As in Java, declaring a variable with a type will always make it local.  
Even if the variable exists in the outer scope, it will be hidden by the 
local variable declaration.  But what of loosely typed variables?  As we've
seen, untyped variable usage looks just like an ordinary Java assignment.  What
do we do if we want to make a local variable with the same name as a global
one?  One answer would be to resort to declaring the variable with a type.  
But if we wish to continue working with loosely typed variables in this case we
have two options:  We can explicitly declare a loosely typed variable with the
BeanShell 'var' type.  Or we can simply qualify our assignment with the 'this.'
qualifier.
<p CLEAR="ALL"/>

If you wish to, you can explicitly declare an untyped variable
(making it local) using the special type 'var'. e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
	var a = 1;
}
foo();
print( a ); // ERROR! a is undefined!
</pre></td></tr></table></center><p/>

'var' is a magic type in BeanShell that represents a loose (untyped) variable.
The default value of a variable declared with 'var' is null.
<p CLEAR="ALL"/>

Alternately, you can use the scope modifier 'this' to explicitly qualify the
variable assignment and make it local. 

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
	this.a = 1;
}
foo();
print( a ); // ERROR! a is undefined!
</pre></td></tr></table></center><p/>

In this example we used the modifier 'this' to qualify an untyped
variable's scope and make it local.  We will explain 'this' and what it means 
in BeanShell scripted methods in the next section on Scripted Objects.  
<p CLEAR="ALL"/>


<h2><a name="Scope_Modifier:_'super'">Scope Modifier: 'super'</a></h2>
<p CLEAR="ALL"/>

Within a method, it is possible to explicitly qualify a variable or 
method reference with the identifier 'super' in order to refer 
to a variable or method defined in an enclosing scope (the scope in which the 
method is defined or "higher"). e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
int a = 42;

foo() {
    int a = 97;
    print( a );
    print( super.a );
}

foo();  // prints 97, 42
</pre></td></tr></table></center><p/>

As in Java, the 'super' modifiers tells the scoping to begin its search for the
variable or method in the parent scope. 
In the case above, the variable 'a' by default refers to the variable in the
local scope.  By qualifying 'a' with 'super' we can refer to the variable 'a'
in the global scope (the "topmost" scope).
<p CLEAR="ALL"/>

So, we've seen that 'super' can be used to refer to the method's parent 
context.  We'll see in the next section how 'this' and 'super' are used
in scripting Objects in BeanShell.
<p CLEAR="ALL"/>

<hr/><!--PAGE BREAK-->

	<h1><a name="Scripted_Objects">Scripted Objects</a></h1>


Many people who use BeanShell use it to write scripts that 
work with existing Java classes and APIs, or perform other kinds of dynamic 
activities for their own applications at run-time without the aid of a 
compiler.  Often this means writing relatively unstructured code -
for example, a sequence of method invocations or loops, all contained in a 
single script file or eval() statement. 
In the previous section we saw that BeanShell is also capable of scripting 
methods, just like Java.  Creating methods and new BeanShell commands 
(which are just methods in their own files) is the 
natural progression of organizing your scripts into re-usable and 
maintainable components.
<p CLEAR="ALL"/>

Beyond methods and structured programming lie, of course, objects and the 
full breadth of object oriented programming.  In Java objects are the products
of classes.  While BeanShell is compatible with standard Java syntax for 
statements, expressions, and methods, you can't yet script new Java classes 
within BeanShell.
Instead, BeanShell allows you to script objects as "method closures", 
similar to the way it is done in Perl 5.x, JavaScript, and other object-capable 
scripting languages.  This style of scripting objects (which we'll describe 
momentarily) is simple and flows very naturally from the style of scripting 
methods.  The syntax, as you'll see, is a straightforward extension of the 
standard Java concept of referring to an object with a 'this' reference.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
In standard Java, a method inside of an object (an instance method) may refer
to the enclosing object using the special variable 'this'.  For example:
<pre>
    // MyClass.java
    MyClass {
        Object getObject() {
            return this; // return a reference to our object
        }
    }
</pre>

In the example above, the getObject() method of MyClass returns a reference
to its own object instance (an instance of the MyClass object) using 'this'.
</td></tr></table></center><p/>

<h2><a name="The_'this'_reference">The 'this' reference</a></h2>

As in most languages, an executing method in BeanShell has its own 
"local" scope 
that holds argument (parameter) variables and locally declared variables.  For
example, in the following code segment any variables that we might use within 
the foo() method will normally only be visible within the scope of foo() and 
for the lifetime of one particular foo() method invocation:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Define the foo() method:
foo() {
    int bar = 42;
    print( bar );
}   

// Invoke the foo() method:
foo();  // prints 42

print( bar ); // Error, bar is undefined here 
</pre></td></tr></table></center><p/>

In the above, the bar variable is local to foo() and therefore not available
outside of the method invocation - it is thrown away when the method exits,
just like a standard Java local variable.
<p CLEAR="ALL"/>

Now comes the twist - In BeanShell you have the option to "hang on" to the 
scope of a method invocation after exiting the method by referring to the 
special 'this' reference.  As in Java, 'this' refers to the current object 
context.   The only difference is that in this case the context is associated
with the method and not a class instance.
<p CLEAR="ALL"/>

By saving the 'this' reference after the method returns, you can continue to 
refer to variables defined within the method, using the standard Java "." 
notation:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    int bar = 42;
    return this;
}

fooObject = foo();
print( fooObject.bar ); // prints 42!
</pre></td></tr></table></center><p/>

In the above, the value returned by the foo() method (the 'this' reference)
can be thought of as an instance of a "foo" object.  Each foo() method 
invocation effectively creates a new object; foo() is now not just a method,
but a kind of object constructor.
<p CLEAR="ALL"/>

In the above case our foo object is not so much an object, but really more of a 
structure.  It contains variables (bar) but no "behavior".  The next twist
that we'll introduce is that BeanShell methods are also allowed to contain 
other methods:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    bar() {
        ...
    }
}
</pre></td></tr></table></center><p/>
Scripted methods may define any number of nested methods in this way, to an 
arbitrary depth.  The methods are "local" to the method invocation.  
<p CLEAR="ALL"/>

Statements and expressions within the enclosing BeanShell method can call 
their "local" methods just like any other method.  (Locally declared methods 
override outer-more methods like local variables hide instance variables in
Java.)  The enclosed methods are not directly visible outside of their
enclosing method.  However, as you might expect, we can invoke them as we
would on a Java object, through an appropriate object reference:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    int a = 42;
    bar() {
        print("The bar is open!");
    }
    
    bar();
    return this;
}

// Construct the foo object
fooObject = foo();     // prints "the bar is open!"
// Print a variable of the foo object
print ( fooObject.a );  // 42
// Invoke a method on the foo object
fooObject.bar();       // prints "the bar is open!"
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

Methods declared inside block structures within methods behave just as if they
were declared directly in the method.  i.e. there are no block-local methods.
For example:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {

	bar() { }

	if ( true ) {
		bar2() { }
	}

	return this;
}
</pre></td></tr></table></center><p/>

In the above example the methods bar() and bar2() are both defined within
foo().
<p CLEAR="ALL"/>

<p CLEAR="ALL"/>
In the next section we'll return to the topic of variable scoping and
go into more depth about how to work with scripted methods and objects.
<p CLEAR="ALL"/>

<hr/><!--PAGE BREAK-->

	<h1><a name="Scope_Modifiers">Scope Modifiers</a></h1>


Now that we've seen how methods can be nested and treated as objects, we
can revisit the topic of variable scope and scope modifiers.
<p CLEAR="ALL"/>

<h2><a name="'this',_'super',_and_'global'">'this', 'super', and 'global'</a></h2>

In the "Scripted Methods" section we described the use of 'super' to refer to a 
method's parent scope (the scope in which the method is defined).  
And in the previous section we talked 
about super's brother 'this', which refers to the current method's scope,
allowing us to think of a method scope as an object.  Now we can see how 
these concepts are related.  Any method scope, and indeed the 'global' scope,
can be thought as an object context. A scripted object can be thought of as
encapsulated in a parent scope that determines its "environment" - its inherited
variables and methods.  
<p CLEAR="ALL"/>

The references 'this', 'super', and 'global' are really the same
kind of reference - references to BeanShell method contexts, which can 
be used as scripted objects.  From here on We'll refer to 'this', 
'super', 'global', and any other reference to a scripted object context in
general as a <em>'this' type reference</em>.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
If you print a 'this' type reference you'll see what it refers to:

<pre>
    BeanShell 1.3 - by Pat Niemeyer (pat@pat.net)
    bsh % print( this );
    'this' reference (XThis) to Bsh object: global
    bsh % foo() { print(this); print(super); }
    bsh % foo();
    'this' reference (XThis) to Bsh object: foo
    'this' reference (XThis) to Bsh object: global
</pre>
</td></tr></table></center><p/>
<p CLEAR="ALL"/>

The above note shows that the foo() method's 'this' reference is local
(named 'foo') and that it's parent is the global scope; the same scope in
which foo is defined.

<h3>'global'</h3>

The scope modifier 'global' allows you to always refer to the top-most
scope.  In the previous note you can see that the top level script context
is called "global" and that it appears again as the 'super' of our foo() 
method.  The global context is always the top scope of the script.  
It is the global namespace of the current interpreter.  Referring
to 'super' from the top scope simply returns the same 'global' again.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
  global.foo = 42; 
</pre></td></tr></table></center><p/>

Global variables are not special in any way.  Their visibility derives simply
from the fact that they are in the topmost scope.  However, for those who do
not like the idea of qualifying anything with "global".  You can always use a
more object oriented approach like the following.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Create a top level object to hold some state
dataholder = object();

foo() {
    ...
    bar() {
        dataholder.value = 42;
    }

    bar();
    print( dataholder.value );
}
    
</pre></td></tr></table></center><p/>

In the above example we used a global object to hold some state, rather than
putting the 'value' variable directly in the global scope. 

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
In the above example we used the BeanShell object() command to create an
"empty" BeanShell scripted object context in which to hold some data.  The
object() command is just a standard empty method named object() that 
returns 'this'.  The variable 'dataholder' above is a 'this' type reference and
has all of the properties of any other BeanShell object scope.
</td></tr></table></center><p/>

<h2><a name="Synchronized_Methods_Revisited">Synchronized Methods Revisited</a></h2>

Now that we have covered the meaning of 'this' and 'super' with respect to
BeanShell methods we can define the meaning of the 'synchronized' modifier
for BeanShell methods.  Synchronized BeanShell methods behave as if they were
in a common class by synchronizing on their common 'super' reference object.
For example, in the four cases in the following example, synchronization occurs
on the same Java object.  That object is the 'this' type reference of the 
global scope (a Beanshell object of type bsh.This):

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
print( this ); // 'this' reference (XThis) to Bsh object: global

// The following cases all synchronize on the same lock
synchronized ( this ) { }     // synchronized block
synchronized int foo () { }   // synchronized method foo()
synchronized int bar () { }   // synchronized method bar()
int gee() {
	synchronized( super ) { }  // synchronized blockinside gee() 
}
</pre></td></tr></table></center><p/>

<hr/><!--PAGE BREAK-->


	<h1><a name="Scripting_Interfaces">Scripting Interfaces</a></h1>


One of the most powerful features of BeanShell is the ability to script 
Java interfaces.  This feature allows you to write scripts that serve
as event handlers, listeners, and components of other Java APIs.  It also 
makes calling scripted components from within your applications easier
because they can be made to look just like any other Java object.
<p CLEAR="ALL"/>

<h2><a name="Anonymous_Inner-Class_Style">Anonymous Inner-Class Style</a></h2>

One way to get a scripted component to implement a Java interface is by 
using the standard Java anonymous inner class syntax to construct a scripted 
object implementing the interface type.  For example:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
buttonHandler = new ActionListener() {
    actionPerformed( event ) { 
        print(event);
    }
};

button = new JButton();
button.addActionListener( buttonHandler );
frame(button);
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

In the above example we have created an object that implements the 
<code>ActionListener</code> interface and assigned it to a variable called 
buttonHandler.
The buttonHandler object contains the scripted method actionPerformed(),
which will be called to handle invocations of that method on the interface.
<p CLEAR="ALL"/>

Note that in the example we registered our scripted ActionListener with a 
JButton using its addActionListener() method.  The JButton is, of course, 
a standard Swing component written in Java.  It has no knowledge that when it 
invokes the buttonHandler's actionPerformed() method it will actually be 
causing the BeanShell interpreter to run a script to evaluate the outcome.
<p CLEAR="ALL"/>

To generalize beyond this example a bit - Scripted interfaces work by looking
for scripted methods to implement the methods of the interface.
A Java method invocation on a script that implements an interface causes 
BeanShell to look for a corresponding scripted method with 
a matching signature (name and argument types).  BeanShell then invokes the 
method, passing along the arguments and passing back any return value.
When BeanShell runs in the same Java VM as the rest of the code, you can
freely pass "live" Java objects as arguments and return values, working
with them dynamically in your scripts; the integration can be seamless.
<p CLEAR="ALL"/>

See also <a href="examples/dragtext.html">the dragText example</a>.
<p CLEAR="ALL"/>

<h2><a name="'this'_references_as_Interface_Types">'this' references as Interface Types</a></h2>

The anonymous inner class style syntax which we just discussed allows you
to explicitly create an object of a specified interface type, just as you
would in Java.  But BeanShell is more flexible than that.  In fact, 
within your BeanShell scripts, any 'this' type script reference can
automatically implement any interface type, as needed.  This means that you can 
simply use a 'this' reference to your script or a scripted object anywhere
that you would use the interface type.  BeanShell will automatically "cast" 
it to the correct type and perform the method delegation for you. 
<p CLEAR="ALL"/>

For example, we could script an event handler for our button even
more simply using just a global method, like this:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
actionPerformed( event ) {
    print( event );
}

button = new JButton("Foo!");
button.addActionListener( this );
frame( button ); 
</pre></td></tr></table></center><p/>

Here, instead of making a scripted object to hold our actionPerformed()
method we have simply placed the method in the current context 
(the global scope) and told BeanShell to look there for the method.
<p CLEAR="ALL"/>

Just as before, when <code>ActionEvents</code> are fired by the button, your 
actionPerformed() method will be invoked.  The BeanShell 'this' reference 
to our script implements the interface and directs method invocations to the 
appropriately named method, if it exists.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
If you want to have some fun, try entering the previous example interactively 
in a shell or on the command line.  You'll see that you can then redefine 
actionPerformed() as often as you like by simply entering the method again.  
Each button press will find the current version in your shell.  In a sense,
you are working inside a dynamic Java object that you are creating and 
modifying as you type.  Neat, huh?  Be the Bean!
</td></tr></table></center><p/>

Of course, you don't have to define all of your interface methods globally.
You can create references in any scope, as we discussed in "Scripting Objects".
For example, the following code creates a scripted message button object which
displays a message when its pushed.  The scripted object holds its own
actionPerformed() method, along with a variable to hold the Frame used for 
the GUI:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
messageButton( message ) {
    JButton button = new JButton("Press Me");
    button.addActionListener( this );
    JFrame frame = frame( button );
 
    actionPerformed( e ) {
        print( message );
        frame.setVisible(false);
    }
}

messageButton("Hey you!");
messageButton("Another message...");
</pre></td></tr></table></center><p/>

The above example creates two buttons, with separate messages.  Each button
prints its message when pushed and then dismisses itself.  
The buttons are created by separate calls to the messageButton() method,
so each will have its own method context, separate local variables, and a 
separate instance of the ActionListener interface handler.  Each registers 
itself (its own method context) as the ActionListener for its button, using 
its own 'this' reference.
<p CLEAR="ALL"/>

In this example all of the "action" is contained in messageButton() method
context.  It serves as a scripted object that implements the interface and
also holds some state, the frame variable, which is used to dismiss the GUI.
More generally however, as we saw in the "Scripting Objects" section,
we could have returned the 'this' reference to the caller, allowing it to 
work with our messageButton object in other ways.
<p CLEAR="ALL"/>

<h2><a name="Interface_Types_and_Casting">Interface Types and Casting</a></h2>

It is legal, but not usually necessary to perform an explicit cast of a 
BeanShell scripted object to an interface type.   For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
actionPerformed( event ) {
    print( event );
}

button.addActionListener( 
    (ActionListener)this ); // added cast
</pre></td></tr></table></center><p/>

In the above, the cast to ActionListener would have been done automatically
by BeanShell when it tried to match the 'this' type argument to the signature
of the addActionListener() method.
<p CLEAR="ALL"/>

Doing the cast explicitly has the same effect, but takes a different route
internally.  With the cast, BeanShell creates the necessary adapter 
that implements the ActionListener interface first, at the time of the cast,
and then later finds that the method is a perfect match.  
<p CLEAR="ALL"/>

What's the difference?  Well, there are times where performing
an explicit cast to control when the type is created may be important. 
Specifically, when you are passing references out of your script, to Java 
classes that don't immediately use them as their intended type.

In our earlier discussion we said that automatic casting happens "within
your BeanShell scripts".  And in our examples so far BeanShell has always
had the opportunity to arrange for the scripted object to become the correct
type, before passing it on.  But it is possible for you to pass a 'this'
reference to a method that, for example, takes the type 'Object', in which
case BeanShell would have no way of knowning what it was destined for later.
You might do this, for example, if you were placing your scripted objects
into a collection (Map or List) of some kind.  In that case, you can 
control the process by performing an explicit cast to the desired type before 
the reference leaves your script.
<p CLEAR="ALL"/>

Another case where you may have to perform a cast is where you are using
BeanShell in an embedded application and returning a scripted object as
the result of an eval() or a get() variable from the Interpreter class.  
There again
is a case where BeanShell has no way of knowing the intended type within
the script.   By performing an explicit cast you can create the type
before the reference leaves your script.
<p CLEAR="ALL"/>
We'll discuss embedded applications of BeanShell in the
"Embedding BeanShell" section a bit later, along with the Interpreter 
getInterface() method, which is another way of accomplishing this type of
cast from outside a script.
<p CLEAR="ALL"/>

<h2><a name="&quot;Dummy&quot;_Adapters_and_Incomplete_Interfaces">"Dummy" Adapters and Incomplete Interfaces</a></h2>

It is common in Java to see "dummy" adapters created for interfaces that
have more than one method.  The job of a dummy adapter is to implement all
of the methods of the interface with stubs (empty bodies), allowing the
developer to extend the adapter and override just the methods of interest.
<p CLEAR="ALL"/>

We hinted in our earlier discussion that BeanShell could handle scripted
interfaces that implement only the subset of methods that are actually used 
and that is indeed the case.  You are free in BeanShell to script only the 
interface methods that you expect to be called.  The penalty for leaving out 
a method that is actually invoked is a special run-time exception: 
java.lang.reflect.UndeclaredThrowableException, which the caller will 
receive.  
<p CLEAR="ALL"/>

The UndeclaredThrowableException is an artifact of Java Proxy API that makes
dynamic interfaces possible.  It says that an interface threw a checked
exception type that was not prescribed by the method signature.  This is 
a situation that cannot normally happen in compiled Java.  So the Java 
reflection API handles it by wrapping the checked exception in this special
unchecked (RuntimeException) type in order to throw it.  
You can get the underlying
error using the exception's getCause() method, which will, in this case, 
reveal the BeanShell EvalError exception, reporting that the scripted method 
of the correct signature was not found.
<p CLEAR="ALL"/>


<h3>The invoke() Meta-Method</h3>

BeanShell provides a very simple short-hand mechanism for scripting interfaces
with large numbers of methods.  You can implement the special method 
<em>invoke( name, args )</em> in any scripted 
context.  The invoke() method will be called to handle the invocation of
any method of the interface that is not defined. For example:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
mouseHandler = new MouseListener() {
    mousePressed( event ) { 
        print("mouse button pressed");  
    }

    invoke( method, args ) { 
        print("Undefined method of MouseListener interface invoked:"
            + name +", with args: "+args
        );
    }
};
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

In the above example we have neglected to implement four of the five 
methods of the MouseListener interface.  They will be handled by the invoke()
method, which will simply print the name of the method and its arguments.
However since mousePressed() is defined it will be called for the interface.
<p CLEAR="ALL"/>

Here is a slightly more realistic example of where this comes in handy.
Let's use the invoke() method to print the names of methods called via
the ContentHandler interface of the Java SAX API, while parsing an XML 
document.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import javax.xml.parsers.*;
import org.xml.sax.InputSource;

factory = SAXParserFactory.newInstance();
saxParser = factory.newSAXParser();
parser = saxParser.getXMLReader();
parser.setContentHandler( this );

invoke( name, args ) {
    print( name );
}

parser.parse( new InputSource(bsh.args[0]) );
</pre></td></tr></table></center><p/>

By running this script with the XML file as an argument, we can see which
of the dozen or so methods of the SAX API are being exercised by the structure 
of the document, without having to write a stub for each of them.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can use the invoke( name, args ) meta-method directly in your own scope or
in the global scope as well, in which case you can handle arbitrary "unknown"
method invocations yourself, perhaps to implement your own "virtual" commands.
Try typing this on the command line:
<pre>
  invoke(name,args) { print("Command: "+name+" invoked!"); }
  noSuchMethod(); // prints "Command: noSuchMethod() invoked!"
</pre>
</td></tr></table></center><p/>

<h2><a name="Threads_-_Scripting_Runnable">Threads - Scripting Runnable</a></h2>

BeanShell 'this' type references can implement the standard java.lang.Runnable 
interface.  So you can declare a "run()" method in your bsh objects and make 
it the target of a Thread:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() {
    run() {
        // do work...
    }
    return this;
}

foo = foo();
// Start two threads on foo.run()
new Thread( foo ).start();
new Thread( foo ).start();
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

BeanShell is thread-safe internally, so as long as your scripts do not 
explicitly do anything ordinarily non-thread safe (e.g. access shared 
variables or objects) you can write multi-threaded scripts.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
You can use the bg() "background" command to run an external script in a 
separate thread.  See bg().
</td></tr></table></center><p/>
<p CLEAR="ALL"/>

<h2><a name="Limitations">Limitations</a></h2>
<p CLEAR="ALL"/>

When running under JDK 1.3 or greater BeanShell can script any kind of 
Java interface.  However when running under JDK 1.2 (or JDK1.1 + Swing) only 
the core AWT and Swing interfaces are available.  To support those legacy
cases a special extension of the 'this' reference implementation (the 
bsh.This class) is loaded which implements these interfaces along with 
Runnable, statically.  
<p CLEAR="ALL"/>

<hr/><!--PAGE BREAK-->

	<h1><a name="Special_Variables_and_Values">Special Variables and Values</a></h1>


In addition to the scope modifiers: 'this', 'super', 'global', BeanShell
supports a number of pre-defined system variables, "magic" values, and methods.
<p CLEAR="ALL"/>

<em>Special Values</em>
<p CLEAR="ALL"/>
<ul>
<li><strong>$_</strong> - The value of the last expression evaluated.  The
strange construct for this is drawn from Perl, but the idea exists in many
scripting languages.  It is useful for getting back 
the last result when you are working interactively.  
</li>

<li><strong>$_e</strong> - The last uncaught exception object thrown.  
This is useful in interactive use for retrieving the last exception to inspect
it for details.
</li>

<li><strong>bsh</strong> - The BeanShell root system object, containing 
system information and variables.</li>

<li><strong>bsh.args</strong> - An array of Strings passed as command 
line arguments to the BeanShell interpreter.</li>

<li><strong>bsh.shared</strong> - A special static space which is 
shared across all interpreter instances.  Normally each bsh.Interpreter 
instance is entirely independent; having its own unique global namespace
and settings.  bsh.shared is implemented as a static namespace in the 
bsh.Interpreter class.  It was added primarily to support communication
among instances for the GUI desktop.
</li>

<li><strong>bsh.console</strong> - If BeanShell is running in 
its GUI desktop mode, this variable holds a reference to the current 
interpreter's console, if it has one.</li>

<li><strong>bsh.appletcontext</strong> - If BeanShell
is running inside an Applet, the current applet context, if one exists.</li>

<li><strong>bsh.cwd</strong> - A String representing the current working
directory of the BeanShell interpreter.  This is used or manipulated by the 
cd(), dir(), pwd(), and pathToFile() commands.</li>

<li><strong>bsh.show</strong> - A boolean value used by the show() command.
It indicates whether results are always printed, for interactive use.
</li>

<li><strong>bsh.interactive</strong> - A boolean indicating whether this 
interpreter running in an interactive mode</li> 

<li><strong>bsh.evalOnly</strong> - A boolean indicating whether this 
interpreter has an input stream or whether is it only serving as an engine 
for eval() operations (e.g. for embedded use).</li>
</ul>
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
The choice of "bsh" for the root system object name was somewhat unfortunate
because it conflicts with the current package name for BeanShell (also bsh).
This means that if you wish to work with BeanShell classes explicitly from
BeanShell scripts (e.g. bsh.Interpreter) you must first import them, e.g.:
<pre>
    import bsh.Interpreter;
    i=new Interpreter();
</pre>
</td></tr></table></center><p/>

<h2><a name="Special_Members_of_'this'_type_References">Special Members of 'this' type References</a></h2>
<p CLEAR="ALL"/>

'this' type references have several "magic" members:  

<ul>

<li><strong>this.variables</strong> - An array of Strings listing the 
variables defined in the current method context (namespace).</li>

<li><strong>this.methods</strong> - An array of Strings listing the methods 
defined the current method context (namespace).</li>

<li><strong>this.interpreter</strong> - A bsh.Interpreter reference to the 
currently executing BeanShell Interpreter object.</li>

<li><strong>this.namespace</strong> - A bsh.NameSpace reference to the BeanShell
NameSpace object of the current method context. See "Advanced Topics".</li>

<li><strong>this.caller</strong> - A bsh.This reference to the calling
BeanShell method context. See "Variables and Scope Modifiers".</li>

<li><strong>this.callstack</strong> - An array of bsh.NameSpace references 
representing the "call stack" up to the current method context. 
See "Advanced Topics".</li>

</ul>
<p CLEAR="ALL"/>

These magic references are primarily used by BeanShell commands. 
<p CLEAR="ALL"/>

<h2><a name="Undefined_Variables">Undefined Variables</a></h2>
<p CLEAR="ALL"/>
You can test to see if a variable is defined using the special value 
<b>void</b>.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
if ( foobar == void )
    // undefined
</pre></td></tr></table></center><p/>

You can return a variable to the undefined state using the unset() command:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
a == void;  // true
a=5;
unset("a"); // note the quotes
a == void;  // true
</pre></td></tr></table></center><p/>

<h2><a name="Setting_the_Command_Prompt">Setting the Command Prompt</a></h2>

Users may set the command line prompt string for use in interactive mode 
by setting the value of the variable bsh.prompt or by defining the scripted
method (or command) getBshPrompt().  
<p CLEAR="ALL"/>

If the command or method getBshPrompt() is defined it will be called to
get a string to display as the user prompt.  For example, one could
define the following method to place the current working directory into
their command prompt:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
	getBshPrompt() { return bsh.cwd + " % "; }
</pre></td></tr></table></center><p/>

The default getBshPrompt() command returns the value of the variable
bsh.prompt if it is defined or the string "bsh % " if not.  If the
getBshPrompt() method or command does not exist, throws an exception, or does
not return a String, a default prompt of "bsh % " will be used.
<p CLEAR="ALL"/>

<hr/><!--PAGE BREAK-->

	<h1><a name="BeanShell_Commands">BeanShell Commands</a></h1>


BeanShell commands appear to the user as pre-defined methods such as 
print(), load(), or save().
BeanShell Commands can be implemented as scripted methods or compiled Java 
classes which are dynamically loaded on demand from the classpath.
We'll talk about adding your own commands in the next section "Adding BeanShell Commands".
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can easily override any BeanShell command simply by defining the method
yourself in your script.  For example:
<p CLEAR="ALL"/>
<pre>
print( arg ) {
    System.out.println( "You printed: " + arg );
}
</pre>
<p CLEAR="ALL"/>
If you define the method in the global scope it will apply everywhere.  If you
define it local to a scripted object it will only apply in that object context.
</td></tr></table></center><p/>

<h2><a name="Commands_Overview">Commands Overview</a></h2>

This is a high level overview of the BeanShell command set.
You can find full documentation for all BeanShell commands in the "BeanShell
Commands Documentation" section of this manual.  See also the "BshDoc" 
section which covers javadoc style documentation of BeanShell script files.
<p CLEAR="ALL"/>

<h3>Interpreter Modes</h3>

The following commands affect general modes of operation of the interpreter.

<table border="1" cellpadding="5">
<tr><td>exit()</td><td>
Exit the interpreter.  (Also Control-D).
</td></tr>
<tr><td>show()</td><td>
Turn on "show" mode which prints the result of every
evaluation that is not of void type.
</td></tr>
<tr><td>setAccessibility()</td><td>
Turn on access to private and protected members of Java classes.
</td></tr>
<tr><td>server()</td><td>
Launch the remote access mode, allowing remote access
to the interpreter from a web browser or telnet client.
</td></tr>
<tr><td>debug()</td><td>
Turns on debug mode.  Note: this is very verbose, 
unstructured output and is primarily of interest to developers.
</td></tr>
<tr><td>setStrictJava()</td><td>
Turn on "strict Java" mode which enforces Java
compatibility by dissallowing loose types and undeclared variables.
</td></tr>
</table>

<p CLEAR="ALL"/><h3>Output</h3>

The following commands are used for output:

<table border="1" cellpadding="5">
<tr><td>print(), error()</td><td>
Print output to standard out or standard error.  print() always goes to the
console, whereas System.out may or may not be captured by a GUI console
or servlet.
</td></tr>
<tr><td>frame()</td><td>
Display the AWT or Swing component in a Frame
</td></tr>
</table>

<p CLEAR="ALL"/><h3>Source and Evaluation</h3>

The following commands are used for evaluation or to run external scripts or
applications:

<table border="1" cellpadding="5">
<tr><td>eval()</td><td>
Evaluate a string as if it were typed in the current scope.
</td></tr>
<tr><td>source(), sourceRelative()</td><td>
Read an external script file into the interpreter and evaluate it in the
current scope
</td></tr>
<tr><td>run(), bg()</td><td>
Run an external file in a subordinate interpreter or in a background
thread in a subordinate interpreter.
</td></tr>
<tr><td>exec()</td><td>
Run a native executable in the host OS
</td></tr>
</table>

<p CLEAR="ALL"/><h3>Utilities</h3>

The following commands are useful utilities:

<table border="1" cellpadding="5">
<tr><td>javap()</td><td>
Print the methods and fields of an object, similar to the output of javap
</td></tr>
<tr><td>which()</td><td>
Like the Unix 'which' command for executables.  Map the classpath and 
determine the location of the specified class.
</td></tr>
<tr><td>load(), save()</td><td> load a serializable object from a file
or save one to a file.  Special handling is provided for certain objects.
</td></tr>
<tr><td>object()</td><td>
Create an "empty" object context to hold variables; analogous to a Map.
</td></tr>
</table>

<p CLEAR="ALL"/><h3>Variables and Scope</h3>

The following commands affect the current scope:

<table border="1" cellpadding="5">
<tr><td>clear()</td><td>Clear all variables, methods and imports from
the current scope.
</td></tr>
<tr><td>unset()</td><td>Remove a variable from the current scope.
(Return it to the "undefined" state).
</td></tr>
<tr><td>setNameSpace()</td><td>
Set the current namespace to a specified scope.  Effectively bind the 
current scope to a new parent scope.
</td></tr>
</table>

<p CLEAR="ALL"/><h3>Classpath</h3>

The following commands manipulate or access the classpath:

<table border="1" cellpadding="5">
<tr><td>addClassPath(), setClassPath(), getClassPath()</td><td>
Modify the BeanShell classpath.
</td></tr>
<tr><td>reloadClasses()</td><td>
Reload a class or group of classes.
</td></tr>
<tr><td>getClass()</td><td>
Load a class explicitly taking into account the BeanShell classpath.
</td></tr>
<tr><td>getResource()</td><td>
Get a resource from the classpath.
</td></tr>
</table>

<p CLEAR="ALL"/><h3>Files and Directories</h3>

The following commands work with files, directories, and the working
directory:

<table border="1" cellpadding="5">
<tr><td>cd(), pwd(), dir(), rm(), mv(), cat()</td><td>
Unix Style file commands.
</td></tr>
<tr><td>pathToFile()</td><td>
Translate a relative path to an absolute path taking into account
the BeanShell current working directory.
</td></tr>
</table>

<p CLEAR="ALL"/><h3>Desktop and Class Browser</h3>

The following commands work with GUI tools:

<table border="1" cellpadding="5">
<tr><td>classBrowser(), browseClass()</td><td>
Open a class browser window or browse a specific class or object.
</td></tr>
<tr><td>desktop()</td><td>
Launch the BeanShell GUI desktop.
</td></tr>
<tr><td>setNameCompletion()</td><td>
Turn on or off name completion in the GUI console.
</td></tr>
</table>
<p CLEAR="ALL"/>
<br/>
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
The dir() command is written in Java; primarily as a demonstration of how
to do this when desired.
</td></tr></table></center><p/>


<hr/><!--PAGE BREAK-->


	<h1><a name="Adding_BeanShell_Commands">Adding BeanShell Commands</a></h1>


BeanShell Commands are scripted methods or compiled Java classes which are 
dynamically loaded from the classpath to implement a method.
All of the standard commands we discuss in this manual live in the BeanShell
JAR file under the path /bsh/commands.
<p CLEAR="ALL"/>

Adding to the set of "prefab" commands supplied with BeanShell is as easy as 
writing any other BeanShell methods.  You simply have to place your 
script into a file named with the same name as the command and place the
file in the classpath.  You may then "import" the commands with the
importCommands() method.  
<p CLEAR="ALL"/>

Command files can be placed anywhere in the BeanShell classpath.
You can use even use the addClassPath() or setClassPath() commands to add new 
command directories or JARs containing commands to your script at any time.
<p CLEAR="ALL"/>

<h2><a name="Hello_World">Hello World</a></h2>

For example, let's make a helloWorld() command:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// File: helloWorld.bsh
helloWorld() { 
    print("Hello World!");
}
</pre></td></tr></table></center><p/>

Place the command file helloWorld.bsh in a directory or JAR in your
classpath and import it with the importCommands() command.  
You can either set the classpath
externally for Java or inside of BeanShell with the addClassPath() command.
For example, suppose we have placed
the file in the path: /home/pat/mycommands/helloWorld.bsh.
We could then do:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
addClassPath("/home/pat");  // If it's not already in our classpath
importCommands("/mycommands");
</pre></td></tr></table></center><p/>

We can now use helloWorld() just like any other BeanShell command.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
helloWorld(); // prints "Hello World!"
</pre></td></tr></table></center><p/>

importCommands() will accept either a "resource path" style path name or a
Java package name.  Either one is simply converted to a resource path or 
Java package name as required to load scripts or compiled BeanShell command
classes.  A relative path (e.g. "mycommands") is turned into an absolute path
by prepending "/".  You may import "loose" commands (like unpackaged classes)
at the top of the classpath by importing "/".
<p CLEAR="ALL"/>
If for example you have placed BeanShell commands along with your other 
classes in a Java package called com.xyz.utils in your classpath, you can 
import those commands with:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// equivalent
importCommands("com.xyz.utils");
importCommands("/com/xyz/utils");
</pre></td></tr></table></center><p/>

Imported commands are scoped just like imported classes.  So if you import
commands in a method or object they are local to that scope.

<h3>Overloaded Commands</h3>

BeanShell command scripts can contain any number of overloaded forms of the
command method, e.g.:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// File: helloWorld.bsh
helloWorld() { 
	print("Hello World!"); 
}
helloWorld( String msg ) { 
	print("Hello World: "+msg); 
}
</pre></td></tr></table></center><p/>

BeanShell will select the appropriate method based on the
usual rules for methods selection.


<h2><a name="Compiled_Commands">Compiled Commands</a></h2>

You can also implement BeanShell commands as compiled classes instead of
scripts if you wish.  Your class name must simply be the name of the command
(matching case as well) and it must implement one or more static invoke()
methods who's signatures match a pattern.  The first two
arguments of the invoke() method must be the bsh.Interpreter
and bsh.CallStack objects that provide context to all BeanShell scripts.
Then any number (possibly zero) of arguments, which are the arguments of the
command may follow.  
BeanShell will select the appropriate method based on the
usual rules for methods selection.
<p CLEAR="ALL"/>

The dir() command is an example of a BeanShell command that is implemented in
Java.   Let's look at a snippet from it to see how it implements a pair of
invoke() methods for the dir() and dir(path) commands.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
/**
	Implement dir() command.
*/
public static void invoke( Interpreter env, CallStack callstack ) 
{
	String dir = ".";
	invoke( env, callstack, dir );
}

/**
	Implement dir( String directory ) command.
*/
public static void invoke( 
	Interpreter env, CallStack callstack, String dir ) 
{
...
}
</pre></td></tr></table></center><p/>

<h2><a name="User_Defined_Commands_with_invoke()">User Defined Commands with invoke()</a></h2>

It is useful to note that the invoke() meta-method which we described in the
section "Scripting Interfaces" can be used directly in scope as well as through
an object reference and one could use this to load arbitrary commands or
implement arbitrary behavior for commands (undefined method calls).  For
example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
invoke( String methodName, Object [] arguments ) { 
	print("You invoked the method: "+ methodName );
}

// invoke() will be called to handle noSuchMethod()
noSuchMethod("foo"); 
</pre></td></tr></table></center><p/>

invoke() is called to handle any method invocations for undefined methods 
within its scope.  In this case we have declared it at the global scope.
<p CLEAR="ALL"/>

<h2><a name="Commands_Scope">Commands Scope</a></h2>

Scripted BeanShell commands are loaded when no existing method matches
the command name.
When a command script is loaded it is sourced (evaluated) in the 'global' scope
of the interpreter.  This means that once the command is loaded the methods
declared in the command script are then defined in the interpreter's global
scope and subsequent calls to the command are simply handled by
the those methods as any other scripted method.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
Note that this means that currently scripted commands
may only be loaded once and then they are effectively cached. 
</td></tr></table></center><p/>
<p CLEAR="ALL"/>

<h2><a name="Getting_the_Caller_Context">Getting the Caller Context</a></h2>

A useful feature of BeanShell for command writers is the 'this.caller'
reference, which allows you to create side effects (set or modify variables) in
the method caller's scope.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
fooSetter() {
    this.caller.foo=42;
}
</pre></td></tr></table></center><p/>

The above command has the effect that after running it the variable 'foo'
will be set in the caller's scope. e.g.:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
fooSetter();
print( foo ); // 42
</pre></td></tr></table></center><p/>

It may appear that we could simply have used the 'super' modifier to accomplish
this and in this case it would have worked.  However it would not have been 
correct in general because the 'super' of fooSetter() always points to the same
location - the scope in which it was defined.   We would like fooSetter() to
set the variable in whatever scope it was called from.
<p CLEAR="ALL"/>

To reiterate:
The 'super' of a method is always
the context in which the method was defined.  But the caller may be any context
in which the method is used.  In the following example,
the parent context of foo() and the caller context of foo() are the same:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() { ... }
foo();
</pre></td></tr></table></center><p/>

But this is not always the case, as for bar() in the following example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() { 
    bar() { ... }
    ...
}

// somewhere
fooObject.bar();
</pre></td></tr></table></center><p/>

The special "magic" field reference: 'this.caller' makes it possible 
to reach the context of whomever called bar().  The 'this.caller' reference 
always refers to the calling context of the current method context.
<p CLEAR="ALL"/>

<img src="../images/caller.gif"/>
<p CLEAR="ALL"/>

The diagram above shows the foo() and bar() scopes, along with the caller's
scope access via 'this.caller'.
<p CLEAR="ALL"/>

This is very useful in writing BeanShell commands.  
BeanShell command methods are always loaded into the global 
scope.  If you refer to 'super' from your command you will simply 
get 'global'.  Often it is desirable to write commands that explicitly have 
side effects in the caller's scope.  The ability to do so makes it possible to
write new kinds of commands that have the appearance of being "built-in" 
to the language.  
<p CLEAR="ALL"/>

A good example of this is the eval() BeanShell command.  eval() evaluates
a string as if it were typed in the current context.  To do this, it sends
the string to an instance of the BeanShell interpreter.  But when it does
so it tells the interpreter to evaluate the string in a specific namespace:
the namespace of the caller; using this.caller.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
    eval("a=5");
    print( a ); // 5
</pre></td></tr></table></center><p/>

The eval() command is implemented simply as:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
eval( String text ) {
	this.interpreter.eval( text, this.caller.namespace );
}
</pre></td></tr></table></center><p/>

As a novelty, you can follow the call chain further back if you want to 
by chaining the '.caller' reference, like so:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
    this.caller.caller...;
</pre></td></tr></table></center><p/>

Or, more generally, another magic reference 'this.callstack' returns an
array of bsh.NameSpace objects representing the full call "stack".  This is
an advanced topic for developers that we'll discuss in another location.

<h2><a name="setNameSpace()">setNameSpace()</a></h2>

In the previous discussion we used the this.caller reference to allow us to
write commands that have side effects in the caller's context.  This is a
powerful tool.  But what happens when one command calls another command that
intends to do this?  That would leave the side effects in the first command's
context, not it's original caller.  Fortunately this doesn't come up all that
often.  But there is a general way to solve this problem.
That is to use the powerful 
setNameSpace() method to "step into" the caller's context.  After that we may
set variables and call methods exactly as if we were in the caller's context
(because we are).  If all commands did this there would be no need to use the
this.caller reference explicitly (indeed, we may make it idiomatic for all 
commands to do this in the future).  
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
myCommand() {
	// "Step into" the caller's namespace.
	setNameSpace( this.caller.namespace );

	// work as if we were in the caller's namespace.
}
</pre></td></tr></table></center><p/>

You can try out the setNameSpace() command with arbitrary object scope's 
as well.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
object = object();

// save our namespace
savedNameSpace = this.namespace;

// step into object's namespace
setNameSpace( object.namespace );

// Work in the object's scope
a=1;
b=2;

// step back 
setNameSpace( savedNameSpace );

print( object.a ); // 1
print( object.b ); // 2

print( a ); // ERROR! undefined
</pre></td></tr></table></center><p/>


<h2><a name="Getting_the_Invocation_Text">Getting the Invocation Text</a></h2>

You can get specific information about the invocation of a method
using namespace.getInvocationLine() and namespace.getInvocationText().
The most important use for this is in support of the ability to write an
assert() method for unit tests that automatically prints the assertion text.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
assert( boolean condition ) 
{
    if ( condition )
        print( "Test Passed..." );
    else {
        print(
            "Test FAILED: "
            +"Line: "+ this.namespace.getInvocationLine()
            +" : "+this.namespace.getInvocationText()
            +" : while evaluating file: "+getSourceFileInfo()
        );
        super.test_failed = true;
    }
}
</pre></td></tr></table></center><p/>

<h2><a name="Working_with_Dirctories_and_Paths">Working with Dirctories and Paths</a></h2>

BeanShell supports the notion of a <em>current working directory</em> for
commands that work with files.  The cd() command can be used to change the
working directory and pwd() can be used to display the current value.
The BeanShell current working directory is stored in the variable bsh.cwd.
<p CLEAR="ALL"/>

All commands that work with files respect the working directory, including
the following:
<p CLEAR="ALL"/>

<ul>
<li>dir()</li>
<li>source()</li>
<li>run(),</li>
<li>cat()</li>
<li>load()</li>
<li>save()</li>
<li>mv()</li>
<li>rm()</li>
<li>addClassPath()</li>
</ul>

<h3>pathToFile()</h3>

As a convenience for writing your own scripts and commands you can use
the pathToFile() command to translate a relative file path to an absolute
one relative to the current working directory.  Absolute paths are unmodified.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
absfilename = pathToFile( filename );
</pre></td></tr></table></center><p/>

<h3>Path Names and Slashes</h3>

When working with path names you can generally just use forward slashes
in BeanShell.  Java localizes forward slashes to the appropriate value
under Windows environments.  If you must use backslashes remember to 
escape them by doubling them:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
dir("c:/Windows"); // ok
dir("c:\\Windows"); // ok
</pre></td></tr></table></center><p/>


<h2><a name="Working_With_Class_Identifiers">Working With Class Identifiers</a></h2>

You may have noticed that certain BeanShell commands such as javap(),
which(), and browseClass() which take a class as an argument can accept any 
type of argument, including a plain Java class identifier.  For example,
all of the following are legal:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
javap( Date.class ); // use a class type directly
javap( new Date() ); // uses class of object
javap( "java.util.Date" ); // Uses string name of class
javap( java.util.Date );  // Use plain class identifier
</pre></td></tr></table></center><p/>

In the last case above we used the plain Java class identifier 
java.util.Date.  In Beanshell this resolves to a bsh.ClassIdentifier
reference.  You can get the class represented by a ClassIdentifier using the 
Name.identifierToClass() method.  Here is an example of how to work
with all of the above, converting the argument to a class type:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
	import bsh.ClassIdentifier;

    if ( o instanceof ClassIdentifier )
        clas = this.namespace.identifierToClass(o);
    if ( o instanceof String)
        clas = this.namespace.getClass((String)o);
    else if ( o instanceof Class )
        clas = o;
    else
        clas = o.getClass();
</pre></td></tr></table></center><p/>


<h2><a name="Working_with_Iterable_Types">Working with Iterable Types</a></h2>

In conjunction with the enhanced for-loop added in BeanShell version 1.3 a
unified API was added to provide support for iteration over composite types.
The bsh.BshIterator interface provides the standard hasNext() and next()
methods of the java.util.Iterator interface, but is available in all versions
of Java and can be created for all composite types including arrays.  
<p CLEAR="ALL"/>

The BeanShell CollectionManager is used to get a BshIterator for an interable
object or array.  It is a dynamically loaded extension, so it provides support
for the java.util.Collections API when available, but does not break 
compatability for Java 1.1 applications.

You can use this in the implementation of BeanShell commands to iterate 
over Enumeration, arrays, Vector, String, StringBuffer and 
(when the java.util.collections API is present) Collections and Iterator.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
cm = CollectionManager.getCollectionManager();
if ( cm.isBshIterable( myObject ) ) 
{
	BshIterator iterator = cm.getBshIterator( myObject );
	while ( iterator.hasNext() )
		i = iterator.next();
}
</pre></td></tr></table></center><p/>

<hr/><!--PAGE BREAK-->

	<h1><a name="Strict_Java_Mode">Strict Java Mode</a></h1>


<em>Note: Strict Java Mode is new and currently breaks some BeanShell tools
and APIs when activated.  The GUI desktop and most BeanShell commands 
will not work with strict Java mode enabled.  
Please see notes at the end of this page</em>
<p CLEAR="ALL"/>

If you are a Java teacher or a student learning the Java language and
you would like to avoid any potential confusion relating to BeanShell's
use of loose variable types, you can turn on Strict Java Mode.  Strict
Java Mode is enabled with the the setStrictJava() command.

When strict Java mode is enabled BeanShell will require typed variable
declarations, method arguments and return types.

For example:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
setStrictJava(true);

int a = 5;

foo=42; // Error! Undeclared variable 'foo'.

bar() { .. } // Error! No declared return type.
</pre></td></tr></table></center><p/>


<hr/><!--PAGE BREAK-->

	<h1><a name="Class_Loading_and_Class_Path_Management">Class Loading and Class Path Management</a></h1>


BeanShell is capable of some very fine grained and sophisticated class 
reloading and modifications to the class path.  BeanShell can even map
the entire class path to allow for automatic importing of classes.


<h2><a name="Changing_the_Class_Path">Changing the Class Path</a></h2>

<strong>addClassPath( URL | path )</strong>
<p CLEAR="ALL"/>
Add the specified directory or archive to the classpath.  Archives may be
located by URL, allowing them to be loaded over the network.
<p CLEAR="ALL"/>
Examples:
<p CLEAR="ALL"/>
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
addClassPath( "/home/pat/java/classes" );
addClassPath( "/home/pat/java/mystuff.jar" );
addClassPath( new URL("http://myserver/~pat/somebeans.jar") );
</pre></td></tr></table></center><p/>

Note that if you add class path that overlaps with the existing Java user 
classpath then the new path will effectively reload the classes in that
area.
<p CLEAR="ALL"/>

If you add a relative path to the classpath it is evaluated to an absolute
path; it does not "move with you".

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
cd("/tmp");
addClassPath("."); // /tmp
</pre></td></tr></table></center><p/>

<strong>setClassPath( URL [] )</strong>
<p CLEAR="ALL"/>
Change the entire classpath to the specified array of directories and/or 
archives.  
<p CLEAR="ALL"/>

This command has some important side effects.  It effectively causes all
classes to be reloaded (including any in the Java user class path at startup).
Please see "Class Reloading" below for further details.
<p CLEAR="ALL"/>

Note: setClassPath() cannot currently be used to make the classpath smaller 
than the Java user path at startup.
<p CLEAR="ALL"/>


<h2><a name="Auto-Importing_from_the_Classpath">Auto-Importing from the Classpath</a></h2>

As an alternative to explicitly importing class names you may use the
following statement to trigger automatic importing:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import *;
</pre></td></tr></table></center><p/>

There may be a significant delay while the class path is mapped.  This is why
auto-importing is not turned on by default.  When run interactively, Bsh will 
report the areas that it is mapping.
<p CLEAR="ALL"/>

It is only necessary to issue the auto-import command once.  Thereafter changes
in the classpath via the addClassPath() and setClassPath() commands will
remap as necessary.
<p CLEAR="ALL"/>

<em>
Note: As of BeanShell 1.1alpha new class files added to the classpath 
(from outside of BeanShell) after mapping will not be seen in imports.
</em>


<h2><a name="Reloading_Classes">Reloading Classes</a></h2>

BeanShell provides an easy to use mechanism for reloading classes from the 
classpath.  It is possible in BeanShell to reload arbitrary subsets of classes 
down to a single class file.  However There are subtle issues to be understood 
with respect to what it means to reload a class in the Java environment. 
Please see the discussion of class loading detail below.  But in a nutshell,
it is important that classes which work together be reloaded together at
the same time, unless you know what you are doing.
<p CLEAR="ALL"/>

<strong>reloadClasses( [ package name ] )</strong>
<p CLEAR="ALL"/>
The most course level of class reloading is accomplished by issuing the 
reloadClasses() command with no arguments.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reloadClasses();
</pre></td></tr></table></center><p/>

This will effectively reload all
classes in the current classpath (including any changes you have made through
addClassPath()).
<p CLEAR="ALL"/>

<em>
Note: that reloading the full path is actually a light weight operation that 
simply replaces the class loader - normal style class loading is done as
classes are subsequently referenced.
</em>
<p CLEAR="ALL"/>

Be aware that any object instances which you have previously created may not 
function with new objects created by the new class loader.  Please see the
discussion of class loading details below.
<p CLEAR="ALL"/>

You can also reload all of the classes in a specified package:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reloadClasses("mypackage.*");
</pre></td></tr></table></center><p/>

This will reload only the classes in the specified package.  The classes will
be reloaded even if they are located in different places in the classpath (e.g.
if you have some of the package in one directory and some in another).
<p CLEAR="ALL"/>

As a special case for reloading unpackaged classes the following commands
are equivalent:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reloadClasses(".*") 
reloadClasses("&lt;unpackaged&gt;")
</pre></td></tr></table></center><p/>
<p CLEAR="ALL"/>

You can also reload just an individual class file:
<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reloadClasses("mypackage.MyClass") 
</pre></td></tr></table></center><p/>

<em>Note: As of alpha1.1 classes contained in archives (jar files) cannot be
reloaded. i.e. jar files cannot be swapped.</em>
<p CLEAR="ALL"/>

<h4>Mapping the path</h4>

Unlike the reloadClases() command which reloads the entire class path,
when you issue a command to reload a package or individual class name
BeanShell must map some portions of the classpath to find the location of 
those class files.  This operation can be time consuming, but it is only
done once.  If running in interactive mode feedback will be given on the
progress of the mapping.
<p CLEAR="ALL"/>

<h2><a name="Loading_Classes_Explicitly">Loading Classes Explicitly</a></h2>

In order to perform an explicit class lookup by name while taking into 
account any BeanShell class path modification you must use a replacement
for the standard Class.forName() method.
<p CLEAR="ALL"/>

The getClass() command will load a class by name, using the BeanShell
classpath.  Alternately, you can consult the class manager explicitly:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
name="foo.bar.MyClass";
c = getClass( name );
c = BshClassManager.classForName( name );  // equivalent
</pre></td></tr></table></center><p/>

<h2><a name="Setting_the_Default_ClassLoader">Setting the Default ClassLoader</a></h2>

The bsh.Interpeter setClassLoader() and bsh.BshClassManager.setClassLoader()
methods can be used to set an external class loader which is consulted
for all basic class loading in BeanShell.  
<p CLEAR="ALL"/>

BeanShell will use the specified class loader at the same point where it 
would otherwise use the plain Class.forName().  If no explicit classpath 
management is done from the script (addClassPath(), setClassPath(), 
reloadClasses()) then BeanShell will only use the supplied classloader.  
If additional classpath management is done then BeanShell will perform that 
in addition to the supplied external classloader.  However BeanShell is not 
currently able to reload classes supplied through the external classloader.  
<p CLEAR="ALL"/>


<h2><a name="Class_Loading_in_Java">Class Loading in Java</a></h2>

A fundamental Java security proposition is that classes may only be loaded 
through a class loader once and that classes loaded through different class
loaders live in different name spaces.  By different name spaces I mean that
they are not considered to be of the same type, even if they came from the
very same class file.
<p CLEAR="ALL"/>
You can think of this in the following way:  When you load classes through
a new class loader imagine that every class name is prefixed with the 
identifier "FromClassLoaderXXX" and that all internal references to other
classes loaded through that class loader are similarly rewritten.  Now if
you attempt to pass a reference to a class instance loaded through another
class loader to one of your newly loaded objects, it will not recognize it
as the same type of class.
<p CLEAR="ALL"/>

BeanShell works with objects dynamically through the reflection API, so
your scripts will not have a problem recognizing reloaded class objects.
However any objects which have you already created might not like them.


<h2><a name="Class_Loading_in_BeanShell">Class Loading in BeanShell</a></h2>

The following is a discussion of the BeanShell class loader architecture,
which allows both course class path extension and fine grained individual
class reloading.
<p CLEAR="ALL"/>

<strong>Thriftiness</strong> - Abiding by the BeanShell thriftiness 
proposition: no class loading code is exercised unless directed by a
command.  BeanShell begins with no class loader and only adds class loading
in layers as necessary to achieve desired effects.
<p CLEAR="ALL"/>

The following diagram illustrates the two layer class loading scheme:
<p CLEAR="ALL"/>
<center>
<img src="../images/bshclassloading.gif"/>
</center>
<p CLEAR="ALL"/>

A "base" class loader is used to handle course changes to the classpath 
including added path.  Unless directed by setClassPath() the base loader will
only add path and will not cover existing Java user class path.  This prevents
unnecessary class space changes for the existing classes.
<p CLEAR="ALL"/>

Packages of classes and individual classes are mapped in sets by class 
loaders capable of handling discrete files.  A mapping of reloaded classes
is maintained.  The discrete file class loaders will also use this mapping
to resolve names outside there space, so when any individual class is reloaded
it will see all previously reloaded classes as well.
<p CLEAR="ALL"/>

The BshClassManager knows about all class loader changes and broadcasts
notification of changes to registered listeners.  BeanShell namespaces use
this mechanism to dereference cached type information, however they do not
remove existing object instances.
<p CLEAR="ALL"/>

Type caching is extremely important to BeanShell performance.  So changing
the classloader, which necessitates clearing all type caches, should be 
considered an expensive operation. 
<p CLEAR="ALL"/>


<hr/><!--PAGE BREAK-->

	<h1><a name="Modes_of_Operation">Modes of Operation</a></h1>


There are currently five basic modes of operation for running BeanShell:

<ul>
<li>Standalone scripts</li>
<li>Embedded in your application</li>
<li>Remote server mode</li>
<li>Servlet mode</li>
<li>Applet mode</li>
</ul>

We'll outline these in this and the coming sections.
<p CLEAR="ALL"/>

BeanShell is also integrated into a number of other tools and development
environments including the Emacs JDE and the NetBeans/Forte for Java IDE.
Please see the web site for articles and information about using BeanShell
within these third party tools.

<h2><a name="Standalone">Standalone</a></h2>

<img src="../images/scriptmode.gif"/>
<br CLEAR="ALL"/>

You can use BeanShell to run scripts from the command line or enter
statements interactively by starting the bsh.Interpreter class.
(See "Quickstart" for instructions on adding BeanShell to your classpath.)
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
 java bsh.Interpreter [ filename ] [ arg ] [ ... ]  // Run a script file
</pre></td></tr></table></center><p/>

There are a few options which can be passed to the Interpreter using Java
system properties:

<ul>
<li><strong>outfile</strong> - Send all output to the specified file by 
redirecting System.out and System.err</li>

<li><strong>debug</strong> - Turn on debugging output by setting to
true.  <em>Note: this mode
is very verbose and unstructured.  It is not intended for general
use.</em></li>

<li><strong>trace</strong> - Setting trace to true turns on method tracing.  
This mode prints each line before it is executed.  <em>Note that this currently 
prints only top level lines as they are parsed and executed by the 
interpreter.  Trace skips over method executions (including bsh commands) 
etc.  This mode is incomplete.  It should be considered experimental.</em>
</li>
</ul>

<h2><a name="Remote">Remote</a></h2>

The bsh.Remote launcher is the equivalent of bsh.Interpreter, but runs
the specified file in a remote BeanShell engine.  The remote engine may
be a servlet mode BeanShell engine (BshServlet) or a native server mode 
remote BeanShell instance (embedded interpreter).
<p CLEAR="ALL"/>

bsh.Remote accepts a URL and filename as arguments:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// servlet mode URL
java bsh.Remote http://localhost/bshservlet/eval test1.bsh

// remote server mode URL
java bsh.Remote bsh://localhost:1234/ test1.bsh
</pre></td></tr></table></center><p/>

An HTTP URL may be specified that points to an instance of BshServlet
(See "Servlet Mode" for details).  Or a native "bsh:" URL may be specified,
pointing to an instance of the BeanShell interpreter running in remote
server mode.

<em>
At the time of this writing bsh: style URLs for accessing native remote
server mode instances are not implemented.
</em>
<p CLEAR="ALL"/>

In either case, bsh.Remote sends the script to the remote engine for
evaluation.  If Remote can parse the retun value of the script as an integer 
it will return the value as the exit status to the command line.  

<h2><a name="Interactive_Use">Interactive Use</a></h2>

One of the most popular uses for BeanShell is, of course, as a "shell" for
interactive experimentation and debugging.  BeanShell can be run in a GUI 
desktop mode that offers a number conveniences like command line history,
cut &amp; paste, and tools for interactive use such as a simple classbrowser.  
We'll talk about the GUI in "The BeanShell Desktop" later.  

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The BeanShell GUI is comprised mostly of a set of BeanShell scripts supplied 
in the JAR file and launched by the BeanShell desktop() command.
</td></tr></table></center><p/>

However BeanShell can also be run interactively in plain text on the command 
line.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
 java bsh.Interpreter   // Run interactively on the command line
</pre></td></tr></table></center><p/>

This is useful for quick "one liners"; however it does not offer 
creature comforts such as command line history and editing.  We should note
that some shells, such as the Windows environment, do command line history 
and editing automatically - providing these features for BeanShell.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can exit from an interactive shell by typing Control-D.
</td></tr></table></center><p/>

The return statement is ignored in interactive mode (it does not exit the 
shell).
<p CLEAR="ALL"/>

<h2><a name="The_.bshrc_Init_File">The .bshrc Init File</a></h2>

When run interactively, BeanShell looks for a startup file called ".bshrc"
in the user's home directory.  If the file is found it is sourced into the
interactive shell.  You can use this to perform setup for your interactive
use.  For example, to add additional default imports or to toggle on the
show() command if you prefer that.
<p CLEAR="ALL"/>

The location of the .bshrc file is determined by the Java system property
"user.home", which has different locations under different operating systems.
The following table lists common locations:

<h3>.bshrc File Location:</h3>

<table border="1" cellpadding="5">
<tr><td>Unix</td><td>$HOME/.bshrc</td></tr>

<tr><td>
Win95/98 single user
</td><td>
C:\Windows\.bshrc 
</td></tr>

<tr><td>
Win98 Multiuser
</td><td>
C:\Windows\Profiles\&lt;username&gt;\.bshrc
</td></tr>

<tr><td>
NT/2K
</td><td> 
C:\Winnt\Profiles\&lt;username&gt;\.bshrc
</td></tr>

</table>

<hr/><!--PAGE BREAK-->


	<h1><a name="Embedding_BeanShell_in_Your_Application">Embedding BeanShell in Your Application</a></h1>


<img src="../images/embeddedmode.gif"/>
<br CLEAR="ALL"/>

BeanShell was designed not only as a standalone scripting language - to run
scripts from files or on the command line -  but to be easily embeddable in 
and extensible by your applications.  When we talk about
embedding BeanShell in your application we mean simply that you can use the
BeanShell Interpreter in your own classes, to evaluate scripts and work with
objects dynamically.  
<p CLEAR="ALL"/>

There are a number of reasons you might use BeanShell in this way.  Here
are a few:
<p CLEAR="ALL"/>

<h3>Highly Customizable Applications</h3>

You can use BeanShell to make your applications highly customizable by users 
without requiring them to compile Java classes or even to know all of the 
Java syntax.  

During development you can use BeanShell to "factor out" volatile or 
environmentally dependent algorithms from your application and leave them 
in the scripting domain while they are under the most intense change.
Later it is easy to move them back into compiled Java if you wish because
BeanShell syntax is Java syntax.
<p CLEAR="ALL"/>

<h3>Macros and Evaluation</h3>

BeanShell can be used as a generic language for "macros" or other complex
tasks that must be described by a user of your application.
For example, the popular JEdit Java editor uses 
BeanShell to allow users to implement macros for key bindings.  This gives
user power to customize the behavior of the editor, using as much (or
as little) of the full power of Java as desired.
<p CLEAR="ALL"/>

Java with loose variables is a very simple and appealing language; especially
because there is already so much Java out there.  Even a non-programmer
will be familiar with the name "Java" and more inclined to want to work
with it than an arbitrary new language.
<p CLEAR="ALL"/>

BeanShell can also be used to perform dynamic evaluation of complex expressions
such as mathematics or computations entered by the user.   Why write an
arithmetic expression parser when you can let your user enter equations using
intermediate variables, operators, and other constructs.  If strict control
is desired, you can generate the script yourself using your own rules, and
still leave the evaluation to BeanShell.

<h3>Simplify Complex Configuration Files</h3>

Many applications use simple Java properties files or XML for the majority
of their runtime configuration.
It is very common in the development of a large applications for configuration
files like this to become increasingly complex.  It can begin in a number
of seemingly harmless ways - with the desire to make "cross references"
inside the config files (XML supports this nicely).  Then comes the desire
to do something like variable substitution - which introduces some new syntax
such as "${variable}" and usually a second pass in the parsing stage.
Usually, at some point, integration with Java forces the introduction of 
class names into the mix.  The configuration files soon want to start
assigning parameters for object construction.  Ultimately what you'll 
discover is that you are creating your own scripting language - and one that
is probably not as easy to read as plain old Java.
<p CLEAR="ALL"/>

BeanShell solves the problem of complex configuration files by allowing
users to work not only with simple properties style values 
(loose variable assignment)
but also to have the full power of Java to construct objects, arrays,
perform loops and conditionals, etc.  And as we'll see, BeanShell scripts
can work seamlessly with objects from the application, <b>without</b>
the need to turn them into strings to cross the script boundary.
<p CLEAR="ALL"/>


<h2><a name="The_BeanShell_Core_Distribution">The BeanShell Core Distribution</a></h2>

Beanshell is fairly small, even in its most general distribution.  The
full JAR with all utilities weighs in at about 250K.  But BeanShell is
also distributed in a componentized fashion, allowing you to choose to add
only the utilities and other pieces that you need.  The core distribution
includes only the BeanShell interpreter and is currently about 130K.  <em>We
expect this size to drop in the future with improvements in the parser
generator.</em>  Any significant new features will always be provided in
the form of add-on modules, so that the core language can remain small.
<p CLEAR="ALL"/>

More and more people are using BeanShell for embedded applications in small
devices.  We have reports of BeanShell running everywhere from palm-tops
to autonomous buoys in the Pacific ocean!


<h2><a name="Calling_BeanShell_From_Java">Calling BeanShell From Java</a></h2>

Invoking BeanShell from Java is easy.   The first step is to create in
instance of the bsh.Interpreter class.  Then you can use it to evaluate
strings of code, source external scripts.  You can pass your data in to
the Interpreter as ordinary BeanShell variables, using the Interpreter
set() and get() methods.
<p CLEAR="ALL"/>

In "QuickStart" we showed a few examples:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import bsh.Interpreter;

Interpreter i = new Interpreter();  // Construct an interpreter
i.set("foo", 5);                    // Set variables
i.set("date", new Date() ); 

Date date = (Date)i.get("date");    // retrieve a variable

// Eval a statement and get the result
i.eval("bar = foo*10");             
System.out.println( i.get("bar") );

// Source an external script file
i.source("somefile.bsh");
</pre></td></tr></table></center><p/>

The default constructor for the Interpreter assumes that it is going to be
used for simple evaluation.  Other constructors allow you to
set up the Interpreter to work with interactive sources including streams
and the GUI console.
<p CLEAR="ALL"/>

<h2><a name="eval()">eval()</a></h2>

The Interprete eval() method accepts a script as a string and interprets it,
optionally returning a result.
The string can contain any normal BeanShell script text with any number of 
Java statements.
The Interpreter maintains state over any number of eval() calls, so you can
interpret statements individually or all together.

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
It is not necessary to add a trailing ";" semi-colon at the end of the 
evaluated string.  BeanShell always adds one at the end of the string.
</td></tr></table></center><p/>

The result of the evaluation of the last statement or expression in the 
evaluated string is returned as the value of the eval().  Primitive types
(e.g int, char, boolean) are returned wrapped in their primitive wrappers
(e.g. Integer, Character, Boolean).
If an evaluation of a statement or expression yields a "void" value; such
as would be the case for something like a for-loop or a void type method
invocation, eval() returns null.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
Object result = i.eval( "long time = 42; new Date( time )" ); // Date
Object result = i.eval("2*2");  // Integer
</pre></td></tr></table></center><p/>

You can also evaluate text from a java.io.Reader stream using eval():

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
reader = new FileReader("myscript.bsh");
i.eval( reader );
</pre></td></tr></table></center><p/>

<h2><a name="EvalError">EvalError</a></h2>

The bsh.EvalError exception is the general exception type for an error in 
evaluating a BeanShell script.  Subclasses of EvalError - ParseException
and TargetError - indicate the specific conditions where a textual 
parsing error was encountered or where the script itself caused an exception 
to be generated.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
try {
    i.eval( script );
} catch ( EvalError e ) {
    // Error evaluating script
}
</pre></td></tr></table></center><p/>

You can get the error message, line number and source file of the error
from the EvalError with the following methods:
<p CLEAR="ALL"/>

<table border="1" cellpadding="5">
<tr><td>
String getErrorText() { 
</td></tr>
<tr><td>
int getErrorLineNumber() { 
</td></tr>
<tr><td>
String getErrorSourceFile() {
</td></tr>
</table>
<p CLEAR="ALL"/>

<h3>ParseException</h3>

ParseException extends EvalError and indicates that the exception was 
caused by a syntactic error in reading the script.  The error message will
indicate the cause.

<h3>TargetError</h3>

TargetError extends EvalError and indicates that the exception was 
not related to the evaluation of the script, but caused the by script itself.
For example, the script may have explicitly thrown an exception
or it may have caused an application level exception such as a NullPointer
exception or an ArithmeticException.
<p CLEAR="ALL"/>

The TargetError contains the "cause" exception.  You can retrieve it 
with the getTarget() method.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
try {
    i.eval( script );
} catch ( TargetError e ) {
    // The script threw an exception
    Throwable t = e.getTarget();
    print( "Script threw exception: " + t );
} catch ( ParseException e ) {
    // Parsing error
} catch ( EvalError e ) {
    // General Error evaluating script
}
</pre></td></tr></table></center><p/>

<h2><a name="source()">source()</a></h2>

The Interpreter source() method can be used to read a script from an external
file:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
i.source("myfile.bsh");
</pre></td></tr></table></center><p/>

The Interpreter source() method may throw FileNotFoundException and 
IOException in addition to EvalError.  Aside from that source() is simply
and eval() from a file.

<h3>set(), get(), and unset()</h3>

As we've seen in the examples thus far, set() and get() can be used to
pass objects into the BeanShell interpreter as variables and retrieve the
value of variables, respectively.
<p CLEAR="ALL"/>

It should be noted that get() and set() are capable of evaluation of
arbitrarily complex or compound variable and field expression.  
For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import bsh.Interpreter;
i=new Interpreter();

i.eval("myobject=object()" );
i.set("myobject.bar", 5);

i.eval("ar=new int[5]");
i.set("ar[0]", 5);

i.get("ar[0]");
</pre></td></tr></table></center><p/>

The get() and set() methods have all of the evaluation capabilities of
eval() except that they will resolve only one variable target or value
and they will expect the expression to be of the appropriate resulting type.
<p CLEAR="ALL"/>

<em>The deprecated setVariable() and getVariable() methods are no longer
used because the did not allow for complex evaluation of variable names</em>
<p CLEAR="ALL"/>

You can use the unset() method to return a variable to the undefined state.


<h3>Getting Interfaces from Interpreter</h3>

We've talked about the usefulness of writing scripts that implement
Java interfaces.  By wrapping a script in an interface you can make it
transparent to the rest of your Java code.

As we described in the "Interfaces" section earlier, within the BeanShell 
interpreter scripted objects automatically implement any interface necessary 
when they are passed as arguments to methods requiring them.  
However if you are going to pass a reference outside of BeanShell you may 
have to perform an explicit cast inside the script, to get it to manufacture 
the correct type.
<p CLEAR="ALL"/>

The following example scripts a global actionPerformed() method and returns a
reference to itself as an ActionListener type:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// script the method globally
i.eval( "actionPerformed( e ) { print( e ); }");

// Get a reference to the script object (implementing the interface)
ActionListener scriptedHandler = 
    (ActionListener)i.eval("return (ActionListener)this");

// Use the scripted event handler normally...
new JButton.addActionListener( scriptedHandler );
</pre></td></tr></table></center><p/>

Here we have performed the explicit cast in the script as we returned the
reference.  (And of course we could have used the standard Java anonymous
inner class style syntax as well.)
<p CLEAR="ALL"/>

An alternative would have been to have used the Interpreter getInterface()
method, which asks explicitly for the global scope to be cast to a specific
type and returned.
The following example fetches a reference to the interpreter global namespace 
and cast it to the specified type of interface type.  

<pre>
Interpreter interpreter = new Interpreter();
// define a method called run()
interpreter.eval("run() { ... }");

// Fetch a reference to the interpreter as a Runnable
Runnable runnable =
    (Runnable)interpreter.getInterface( Runnable.class );
</pre>
<p CLEAR="ALL"/>

The interface generated is an adapter (as are all interpreted interfaces).  
It does not interfere with other uses of the global scope or other 
references to it.
We should note also that the interpreter does *not* require that any or all 
of the methods of the interface be defined at the time the interface is
generated.  However if you attempt to invoke one that is not defined
you will get a runtime exception.
<p CLEAR="ALL"/>

<h2><a name="Multiple_Interpreters_vs._Multi-threading">Multiple Interpreters vs. Multi-threading</a></h2>

A common design question is whether to use a single BeanShell
interpreter or multiple interpreter instances in your application.  
<p CLEAR="ALL"/>

The Interpreter class is, in general, thread safe and allows you to 
work with threads, within the normal bounds of the Java language.  BeanShell
does not change the normal application level threading issues of multiple 
threads from accessing the same variables: you still have to synchronize
access using some mechanism if necessary. 
However it is legal to perform multiple simultaneous evaluations. 
You can also write multi-threaded scripts within the language, as we discussed
briefly in "Scripting Interfaces".
<p CLEAR="ALL"/>

Since working with multiple threads introduces issues of synchronization
and application structure, you may wish to simply create multiple Interpreter
instances.  BeanShell Interpreter instances were designed to be very light
weight.  Construction time is usually negligible and in simple tests, we have 
found that it is possible to maintain hundreds (or even thousands) of 
instances.
<p CLEAR="ALL"/>

There are other options in-between options as well.  It is possible to 
retrieve BeanShell scripted objects from the interpreter and "re-bind" them
again to the interpreter.  We'll talk about that in the next section.
You can also get and set the root level bsh.NameSpace object for the
entire Interpreter.  The NameSpace is roughly equivalent to a BeanShell method
context.   Each method context has an associated NameSpace object.

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You can clear all variables, methods, and imports from a scope using
the clear() command.
</td></tr></table></center><p/>


<em>Note: at the time of this writing the synchronized language keyword
is not implemented.  This will be corrected in an upcoming release.</em>
<p CLEAR="ALL"/>

See also "The BeanShell Parser" for more about performance issues.

<h2><a name="Serializing_Interpreters_and_Scripted_Objects">Serializing Interpreters and Scripted Objects</a></h2>

The BeanShell Interpreter is serializable, assuming of course that all
objects referenced by variables in the global scope are also serializable.
So you can save the entire static state of the interpreter by serializing
it and storing it.  Note that serializing the Intepreter does not "freeze"
execution of BeanShell scripts in any sense other than saving the current
state of the variables.  In general if you serialize an Interpreter while 
it is executing code the results will be undetermined.  De-serializing an
interpreter does not automatically restart method executions; it simply
restores state.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
There is serious Java bug that affects BeanShell serializability in Java
versions prior to 1.3.  When using these versions of Java the primitive type 
class identifiers cannot be de-serialized.  See the FAQ for a workaround.
</td></tr></table></center><p/>

It is also possible to serialize individual BeanShell scripted objects
('this' type references and interfaces to scripts).  The same rules apply.
One thing to note is that by default serializing a scripted object context
will also serialize all of that object's parent contexts up to the global
scope - effectively serializing the whole interpreter.
<p CLEAR="ALL"/>

To detach a scripted object from its parent namespace you can use the
namespace prune() method:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// From BeanShell
object.namespace.prune();

// From Java
object.getNameSpace().prune();
</pre></td></tr></table></center><p/>

To bind a BeanShell scripted object back into a particular method scope
you can use the bind() command:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// From BeanShell
bind( object, this.namespace );

// From Java
bsh.This.bind( object, namespace, interpreter );
</pre></td></tr></table></center><p/>

The bind() operation requires not only the namespace (method scope) into which 
to bind the object, but an interpreter reference as well.  The interpreter
reference is the "declaring interpreter" of the object and is used for cases
where there is no active interpreter - e.g. where an external method call
from compiled Java enters the object.
<p CLEAR="ALL"/>

The BeanShell save() command which serializes objects recognize when you are 
trying to save a BeanShell scripted object (a bsh.This reference) type and 
automatically prune()s it from the parent namespace, so that saving the object 
doesn't drag along the whole interpreter along for the ride.  Similarly, 
load() binds the object to the current scope.
<p CLEAR="ALL"/>


<hr/><!--PAGE BREAK-->


	<h1><a name="Remote_Server_Mode">Remote Server Mode</a></h1>


<img src="../images/remotemode.gif"/>
<br CLEAR="ALL"/>

Remote server mode lets you access a BeanShell Interpreter inside of a 
remote VM.
With remote server mode activated you can literally telnet into the running
application and type commands at the BeanShell shell prompt.  Or, even better, 
you can use any web browser to bring up a remote GUI console.
<p CLEAR="ALL"/>


<p CLEAR="ALL"/>
<center>
<table width="90%" border="1" cellpadding="5">
<tr><td>
<strong>Warning:</strong>
<br CLEAR="ALL"/>
<b>When activated remote server mode can provide unrestricted access
to all parts of your application and the host server.  This mode should
not be used in production environments or anywhere that server security
is an issue.
</b>
</td></tr>
</table>
</center>
<p CLEAR="ALL"/>

To enable remote access simply issue the BeanShell server() command, specifying
a base port number:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
server(1234);
// Httpd started on port: 1234
// Sessiond started on port: 1235
</pre></td></tr></table></center><p/>

At this point BeanShell will run two services: a tiny HTTP server on the
port you specified and the BeanShell telnet session server on the next port
(the port you specified + 1).
<p CLEAR="ALL"/>

<h2><a name="Web_Browser_Access">Web Browser Access</a></h2>

After starting the server you can connect your web browser to the port
you specified.   BeanShell will respond by sending an HTML page offering
you a choice of the Swing based JConsole or the older AWTConsole.  You
may choose whichever is appropriate for your web browser.
<p CLEAR="ALL"/>

You can skip this decision page by hitting one of the following URLs directly:

<table border="1" cellpadding="5">

<tr><td>http://&lt;yourserver&gt;:&lt;port&gt;/remote/jconsole.html</td><td>
Swing based JConsole page
</td></tr>

<tr><td>http://&lt;yourserver&gt;:&lt;port&gt;/remote/awtconsole.html</td><td>
Minmal (old) AWT based Console page
</td></tr>

</table>

The httpd server then serves the remote console applet.
When it starts you will have a BeanShell session that looks like the 
regular console, but is connected to the remote BeanShell VM.
<p CLEAR="ALL"/>

<img src="../images/remoteconsole.gif"/>
<p CLEAR="ALL"/>

You can open as many sessions into that VM as you like in this way, but 
note that unlike the BeanShell desktop environment -
<strong>
All remote sessions share the same global scope.
</strong>
You are effectively working in the same interpreter instance for all 
connections.  This is intended as a feature, as the primary usefulness of
this mode is for debugging.  You can set variables and access components
across many sessions.
<p CLEAR="ALL"/>

<h2><a name="Example">Example</a></h2>

Let's look at a quick example of how you might start a remote session from
within your application:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Java code
import bsh.Interpreter;
i = new Interpreter();

i.set( "myapp", this );  // Provide a reference to your app
i.set( "portnum", 1234 );  
i.eval("setAccessibility(true)"); // turn off access restrictions

i.eval("server(portnum)"); 
</pre></td></tr></table></center><p/>

Here we have set up the interpreter instance just as we would to do any
other kind of scripting - passing in Java objects using set().  In this case
we passed a general reference to our application using 'this', as well.
We have turned on accessibility so that we can access private and protected
members of our classes (useful for debugging).  Finally we start the server
on the desired port.

<h2><a name="Telnet_Access">Telnet Access</a></h2>

We mentioned earlier that BeanShell starts its telnet session server on
the port next to the HTTP port.  You can use any telnet client to access
a BeanShell command line directly, in text only-mode, without the use of
a web browser.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
telnet &lt;myhost&gt; &lt;port+1&gt;
</pre></td></tr></table></center><p/>

Note that this command line is not very friendly.  In particular it does not
respond to gratuitous newlines with a new prompt (as the text only 
Interpreter command line does).
<p CLEAR="ALL"/>

<em>
At the time of this writing there is no explicit way to close a session.
BeanShell will simply detect the end of streams.
</em>

<hr/><!--PAGE BREAK-->


	<h1><a name="BshServlet_and_Servlet_Mode_Scripting">BshServlet and Servlet Mode Scripting</a></h1>


BshServlet is a simple servlet that can be used to evaluate BeanShell
scripts inside of an application server or servlet container.  BshServlet
accepts BeanShell scripts via the POST method, evaluates them capturing output
(optionally including standard out and standard error) and returns the results.
<p CLEAR="ALL"/>

BshServlet has a simple form based interface for interactive experimentation
(analogous to the remote server mode).  But more generally you can send
standalone BeanShell scripts from the command line to the BshServlet for
evaluation using the bsh.Remote launcher.  bsh.Remote complements
bsh.Interpreter and bsh.Console as a launch point for BeanShell.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
You may find BshServlet useful for writing unit tests that must run inside an
application server environment.  In this mode BshServlet can be used
in the same way as or in combination with the Jakarta project's cactus.
</td></tr></table></center><p/>

<h2><a name="Deploying_BshServlet">Deploying BshServlet</a></h2>

To test drive BshServlet you can grab one of the following sample application 
WAR files here:

<ul>
<li><a href="http://www.beanshell.org/bshservlet.war">
http://www.beanshell.org/bshservlet.war</a></li>
<li>
<a href="http://www.beanshell.org/bshservlet-wbsh.war">
http://www.beanshell.org/bshservlet-wbsh.war</a> 
<em>Rename this file to "bshservlet.war" for use.</em>
</li>
</ul>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
A WAR file is a Web Application Archive.  It is a JAR file containing HTML,
images, servlets, and configuration files comprising a complete web 
application.  Web applications can usually be deployed to a servlet container by
simply dropping the WAR file into a special directory.
</td></tr></table></center><p/>

The first file, bshservlet.war, assumes that BeanShell has been installed in 
your application server's classpath.  It includes only the web.xml file 
necessary to deploy an instance of the test servlet and an index.html README 
file.  

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
To install BeanShell in the Tomcat server classpath place the bsh.jar file in 
common/lib.  To use BeanShell in Weblogic you must upgrade its version of the 
package.  See <a href="weblogic.html">Upgrading BeanShell in Weblogic</a>
(http://www.beanshell.org/weblogic.html).
</td></tr></table></center><p/>

The second WAR, bshservlet-wbsh.war, includes a copy of the BeanShell 
application bsh.jar inside the WAR's lib directory.  This WAR includes 
everything you need to just drop the WAR into an application server.  

<p/><center><table cellpadding="5" border="1" width="90%"><tr><td bgcolor="#eeeebb"><strong>Note:</strong><br CLEAR="ALL"/>
Using bshservlet-wbsh.war will still *not* work in Weblogic 6.x unless 
you upgrade Weblogic's internal version of BeanShell first.  
See <a href="weblogic.html">Upgrading BeanShell in Weblogic</a>.
(http://www.beanshell.org/weblogic.html).
</td></tr></table></center><p/>

To use the servlet for testing your own applications you will probably want to
deploy an instance of the test servlet in your WAR file.  This will allow 
the test servlet to to share a classloader with your webapp so that you can 
test things like application classes and EJB local homes.  Since the servlet 
is included in the standard BeanShell distribution, all that is necessary to 
do this is to include bsh.jar and add an entry to your wegapp's web.xml file.  
Here is an example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre> 
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE web-app
    PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
    "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;

&lt;web-app&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;bshservlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;bsh.servlet.BshServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;bshservlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eval&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</pre></td></tr></table></center><p/>

The above example deploys an instance of BshServlet under the name "/eval".
The full path to the servlet will then depend on the name given to the
webapp WAR file.  For example if the above appears in a WAR file named
"myapp.war" then the path would be:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
http://localhost/myapp/eval
</pre></td></tr></table></center><p/>

<h2><a name="Running_Scripts">Running Scripts</a></h2>

After deploying the servlet, test it by fetching the default page with 
your web browser.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
http://localhost/bshservlet/eval
</pre></td></tr></table></center><p/>

You can use the servlet interactively through the form that it generates, or,
more importantly, through the command line launcher bsh.Remote.
bsh.Remote accepts a URL for a target bsh interpreter 
and one or more file names to send to that server, printing the results.  

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
  java bsh.Remote http://localhost/bshservlet/eval test1.bsh
</pre></td></tr></table></center><p/>

You can execute remote scripts programmatically using the static method 
bsh.Remote.eval().
<p CLEAR="ALL"/>

If bsh.Remote can parse the retun value as an integer it will 
return it as the exit status to the command line.  
<p CLEAR="ALL"/>

<h2><a name="The_Script_Environment">The Script Environment</a></h2>

Scripts have access to the servlet environment through two predefined variables:

<ul>
<li>bsh.httpServletRequest</li>
<li>bsh.httpServletResponse</li>
</ul>

which are the standard servlet request and response objects, respectively.
<p CLEAR="ALL"/>

When set to "raw" output mode via the forms interface or servlet parameter
(described in the next section) the script is expected to generate the 
complete response using the httpServletResponse object.  This means that you 
can have your script generate HTML or other output to be consumed by the client.

For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre> 
// Server side script generates HTML response page
bsh.httpServletResponse.setContentType("text/html");
out = bsh.httpServletResponse.getWriter();
out.println("&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;");
</pre></td></tr></table></center><p/>

More generally, you can use the httpServletRequest to get access to the
server environment such as the servlet session object.  You can also access
all of the standard Java tools such as JNDI to fetch EJB homes, etc. and
perform testing or script activities.

<h2><a name="BshServlet_Parameters">BshServlet Parameters</a></h2>

The following parameters are recognized by BshServlet:

<table border="1" cellpadding="5">
<tr><td>Parameter</td><td>Value</td></tr>
<tr><td><strong>bsh.script</strong></td><td>The BeanShell Script</td></tr>
<tr><td><strong>bsh.servlet.captureOutErr</strong></td><td>"true" - 
capture standard out and standard error during the evaluation of the 
script.  Note: this is inherently non-thread safe.  All output from the
VM will be captured.
</td></tr>
<tr><td><strong>bsh.servlet.output</strong></td><td>"raw" - Do not generate
the servlet HTML result page.  Instead rely on the script to generate the
complete result using the servlet response.
<tr><td><strong>bsh.client</strong></td><td>"remote" - set by the bsh.Remote
launcher to indicate that results should be raw and the return value should
be encoded for transport back to the client.</td></tr>
</td></tr>
</table>

<hr/><!--PAGE BREAK-->

	<h1><a name="The_BeanShell_Demo_Applet">The BeanShell Demo Applet</a></h1>


<img src="../images/appletmode.gif"/>
<br CLEAR="ALL"/>
<p CLEAR="ALL"/>

The BeanShell Applet is primarily for demonstration and educational purposes.
It allows you to experiment with BeanShell live, directly in your web
browser.  

You can try the applet live at the following locations:
<p CLEAR="ALL"/>

<h3>Swing JConsole Applet</h3>
A Swing enabled JConsole usable with the Java plug-in 
(or other swing capable browser:
<p CLEAR="ALL"/>

<a href="http://www.beanshell.org/jbshdemo.html">
BeanShell Demo with Swing Console</a>
(http://www.beanshell.org/jbshdemo.html)
<p CLEAR="ALL"/>

<h3>AWT Console Applet</h3>
A minimal (not very good) AWT based console that should work in any browser.
<p CLEAR="ALL"/>

<a href="http://www.beanshell.org/awtbshdemo.html">
BeanShell Demo with simple AWT Console</a>
(http://www.beanshell.org/awtbshdemo.html)
<p CLEAR="ALL"/>

<h3>Signed JConsole Applet</h3>

There are many additional security restrictions on Applets and this limits
what you can do with BeanShell in this mode.  For unrestricted access 
try the signed version of the applet here.  It requires the Java 1.4 plug-in
to function.
<p CLEAR="ALL"/>

A Swing enabled JConsole as a signed applet with the Java plug-in 
(or other swing capable browser).  The signed
applet will allow you unrestricted access to your environment through
scripting.
<p CLEAR="ALL"/>

<a href="http://www.beanshell.org/signedjbshdemo.html">
BeanShell Demo with Swing Console - Signed Applet</a>
(http://www.beanshell.org/signedjbshdemo.html)
<p CLEAR="ALL"/>

<hr/><!--PAGE BREAK-->

	<h1><a name="BeanShell_Desktop">BeanShell Desktop</a></h1>


<img src="../images/splash1.jpg"/>
<p CLEAR="ALL"/>

The BeanShell Desktop is a simple GUI environment that provides multiple
bsh shell windows (MDI), a simple text editor, and a simple class browser.
The desktop is mostly implemented by BeanShell scripts, launched by the
desktop() command.
<p CLEAR="ALL"/>

<h2><a name="Shell_Windows">Shell Windows</a></h2>

<img src="../images/colorconsole.jpg"/>
<p CLEAR="ALL"/>

The bsh console windows provide simple command line editing, history,
cut &amp; paste, and variable and class name completion. 
<p CLEAR="ALL"/>

<h2><a name="Editor_Windows">Editor Windows</a></h2>

<img src="../images/editorwindow.gif"/>
<p CLEAR="ALL"/>

<h2><a name="The_Class_Browser">The Class Browser</a></h2>

<img src="../images/bshclassbrowser.gif"/>
<p CLEAR="ALL"/>

<hr/><!--PAGE BREAK-->

	<h1><a name="BshDoc_-_Javadoc_Style_Documentation">BshDoc - Javadoc Style Documentation</a></h1>


<em>BshDoc requires JDK1.4 and BeanShell 1.2b6 or greater to run</em>
<p CLEAR="ALL"/>

BshDoc is a BeanShell script that supports supports javadoc style 
documentation of BeanShell scripts.
BshDoc parses one or more BeanShell script files for method 
information and javadoc style formal comments.  Its output is an XML 
description of the files, containing all of the method signature and comment 
information.

An XSL stylesheet, bshcommands.xsl, supplied with the user manual source,
can be used to render the XML to a nicely indexed HTML document describing
BeanShell commands.
<p CLEAR="ALL"/>

The bshdoc.bsh script is currently distributed with the 
<a href="http://www.beanshell.org/developer.html">source distribution</a>.
An example of the styled output of this command is the 
"BeanShell Commands Documentation" section of this user manual.
That section is automatically generated as part of the build process by running 
bshdoc.bsh on bsh/commands/*.bsh.  See the source distribution Ant build
file for an example of how to do this and the user manual Ant build file
for an example of using a stylesheet to build your documents.
<p CLEAR="ALL"/>

<h2><a name="BshDoc_Comments">BshDoc Comments</a></h2>

BshDoc comments look just like JavaDoc comments and may include 
HTML markup and javadoc style @tags.  If you wish to use the associates XSL 
stylesheet, you should use well formed XHTML for you documentation. 
(Always close tags, etc.). e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre> 
/**
    This is a javadoc style comment.
    &lt;pre&gt;
        &lt;b&gt;Here is some HTML markup.&lt;/b&gt;
        &lt;p/&gt;
        Here is some more.
    &lt;/pre&gt;

    @author Pat Niemeyer
*/
</pre></td></tr></table></center><p/>

Javadoc style @tags are parsed by bshdoc for inclusion in the XML output.  
Currently they are only recognized at the start of a line and they terminate 
the comment. (i.e. they must come at the end of the comment).
<p CLEAR="ALL"/>

BshDoc identifies two kinds of Javadoc style comments:  File Comments
and Method Comments.
Method comments are comments that appear immediately before a method 
declaration with no statements intervening.
File comments are comments that appear as the first statement of a script 
<b>and</b> are not method comments.  If a comment appears as the first 
statement in a script and is also immediately followed by a method declaration
it is considered a method comment.
<p CLEAR="ALL"/>


<h2><a name="BshDoc_XML_Output">BshDoc XML Output</a></h2>

To use BshDoc, run the bshdoc.bsh script on one or more BeanShell script
files:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
java bsh.Interpreter bshdoc.bsh myfile.bsh [ myfile2.bsh ] [ ... ] &gt; output.xml
</pre></td></tr></table></center><p/>

The output goes to standard out.  It looks something like this:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>&lt;!-- This file was auto-generated by the bshdoc.bsh script --&gt;
&lt;BshDoc&gt;
  &lt;File&gt;
    &lt;Name&gt;foo&lt;/Name&gt;
    &lt;Method&gt;
      &lt;Name&gt;doFoo&lt;/Name&gt;
      &lt;Sig&gt;doFoo ( int x )&lt;/Sig&gt;
      &lt;Comment&gt;
        &lt;Text&gt;&amp;lt;![CDATA[ doFoo() method comment. ]]&amp;gt;&lt;/Text&gt;
        &lt;Tags&gt;
        &lt;/Tags&gt;
      &lt;/Comment&gt;
    &lt;/Method&gt;
    &lt;Comment&gt;
        &lt;Text&gt;&amp;lt;![CDATA[ foo file comment. ]]&amp;gt;&lt;/Text&gt;
        &lt;Tags&gt;
        &lt;/Tags&gt;
    &lt;/Comment&gt;
  &lt;/File&gt;
&lt;/BshDoc&gt;</pre></td></tr></table></center><p/>

<h2><a name="The_bshcommands.xsl_stylesheet">The bshcommands.xsl stylesheet</a></h2>

The bshcommands.xsl stylesheet can be used to render the output of bshdoc.bsh
to an indexed HTML page describing BeanShell commands.
<p CLEAR="ALL"/>

The bshcommands.xsl stylesheet is intended for scripts that serve as 
BeanShell commands.  These are script files containing one or more overloaded
methods which have the same name as the filename containing them.

The BshDoc script produces a complete description of any BeanShell script
file.  However the supplied bshcommands.xsl stylesheet does not necessarily 
use all of this information.  Specifically, it does not present all 
individual method comments.  Instead it tries to identify the comments 
pertaining to the command, based upon the file name.  It (the XSL stylesheet) 
applies some logic to choose either the single File Comment if it exists or 
the Method Comment of the first method matching the filename.  Another 
stylesheet could (and will) be easily created for more general BeanShell 
file documentation.  Please check the web site for updates.

<p CLEAR="ALL"/>
Method signatures displayed for methods can be overridden for the 
bshcommands.xsl stylesheet by explicitly supplying them in special 
javadoc @method tags within a 
Method Comment.  For example you might do this to provide a more
verbose description for loosely typed arguments to a BeanShell command.  
The bshcommands.xsl stylesheet will use the @method tag signatures in lieu 
of autogenerated ones when they are present.  So you can also use this tag to 
determine exactly which methods from a file are listed if you wish.
e.g.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
/**
    BshDoc for the foo() command.
    Explicitly supply the signature to be displayed for the foo() method.

    @method foo( int | Integer ) and other text...
*/
foo( arg ) { ... }
</pre></td></tr></table></center><p/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
BshDoc uses the bsh.Parser API to parse the BeanShell script files without
actually running them.  bshdoc.bsh is not very complex.  Take a look at it
to learn how to use the parser API.
</td></tr></table></center><p/>

<hr/><!--PAGE BREAK-->

	<h1><a name="The_BeanShell_Parser">The BeanShell Parser</a></h1>


This BeanShell parser class bsh.Parser is used internally by the BeanShell
Interpreter.  It is responsible for the lexical parsing of the input text,
the application of the grammar structure, and the building of an internal
representation of the BeanShell script file called an "abstract syntax tree" 
(AST).
<p CLEAR="ALL"/>

The Parser just analyzes the language syntax.  It knows only how to parse the 
structure of the language - it does not interpret names, or execute methods 
or commands.  You can use the Parser directly if you have a need to 
analyze the structure of BeanShell scripts or Java methods and statements
in general.
<p CLEAR="ALL"/>

<h2><a name="Validating_Scripts_With_bsh.Parser">Validating Scripts With bsh.Parser</a></h2>

You can use the Parser class from the command line to do basic structural 
validation of BeanShell files without actually executing them. e.g.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
java bsh.Parser [ -p ] file [ file ] [ ... ]
</pre></td></tr></table></center><p/>

The -p option causes some of the abstract syntax to be printed.
<p CLEAR="ALL"/>

The parser will detect any syntax errors in the script and print an error.
Note again that names, imports, and string evaluations are analyzed only for
syntax - not content or meaning.
<p CLEAR="ALL"/>

<h2><a name="Parsing_and_Performance">Parsing and Performance</a></h2>

It is useful to have a high level understanding how BeanShell works
with scripts to understand performance issues.
<p CLEAR="ALL"/>

The first time a script is read or sourced into an interpreter, 
BeanShell uses the parser to parse the script internally to an AST.
The AST consists of Java object representations of all of the language
structures and objects.  The AST consists of Java classes, but is 
<em>not</em> the same as compiled Java code.  When the script is "executed"
BeanShell steps through each element of the AST and tells it to perform
whatever it does (e.g. a variable assignment, for-loop, etc.).  
This execution of the ASTs is generally much faster than the original parsing 
of the text of the method.  It is really only limited by the speed of the
application calls that it is making, the speed of the Java reflection API,
and the efficiency of the implementation of the structures in BeanShell.
<p CLEAR="ALL"/>

When parsing "line by line" through a BeanShell script the ASTs are routinely
executed and then thrown away.  However the case of a BeanShell method
declaration is different.  A BeanShell method is parsed only once: when it
is declared in the script.  It is then stored in the namespace like any
variable.  Successive invocations of the method execute the ASTs again, but
do not re-parse the original text.
<p CLEAR="ALL"/>

This means that successive calls to the same scripted method are as fast
as possible - much faster than re-parsing the script each time.  
You can use this to your advantage when
running the same script many times simply by wrapping your code in the form
of a BeanShell scripted method and executing the method repeatedly, rather
than sourcing the script repeatedly.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// From Java
import bsh.Interpreter;
i=new Interpreter();

// Declare method or source from file
i.eval("foo( args ) { ... }");

i.eval("foo(args)"); // repeatedly invoke the method
i.eval("foo(args)");
...
</pre></td></tr></table></center><p/>

In the above example we defined a method called foo() which holds our 
script.  Then we executed the method repeatedly.  The foo() method was
parsed only once: when its declaration was evaluated.  Subsequent invocations
simply execute the AST.

<h2><a name="Parsing_Scripts_Procedurally">Parsing Scripts Procedurally</a></h2>

If you are willing to learn about the BeanShell abstract syntax tree classes
you can use the Parser to parse a BeanShell script into its ASTs like this:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
in=new FileReader("somefile.bsh");
Parser parser = new Parser(in);
while( !(eof=parser.Line()) ) {
    SimpleNode node = parser.popNode();
    // Use the node, etc. (See the bsh.BSH* classes)
    ...
}
</pre></td></tr></table></center><p/>

To learn more about the abstract syntax tree please download the source
distribution and consult the source documentation.
<p CLEAR="ALL"/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The BshDoc bshdoc.bsh script uses the parser to extract method signatures
and comments from a BeanShell file.  Check it out for a more realistic
example.
</td></tr></table></center><p/>

<em>Note: Many components of the AST classes are not public at this time.
Use setAccessibility(true) to access them.</em>

<hr/><!--PAGE BREAK-->


	<h1><a name="Using_JConsole">Using JConsole</a></h1>


<img src="../images/colorconsole.jpg"/>
<p CLEAR="ALL"/>

The bsh.util.JConsole is a light weight graphical shell console window,
with simple command editing and history capabilities.  BeanShell uses
the JConsole for the GUI desktop mode again in the JRemoteApplet
for the remote server mode.
<p CLEAR="ALL"/>

You can use the JConsole to provide an interactive BeanShell prompt in 
your own applications.  
You are free to use the JConsole for your own purposes outside of BeanShell
as well!  It is a fairly generic shell window easily attached to any kind of 
streams or through the simple console interface.
<p CLEAR="ALL"/>

JConsole is a Swing component.  Embed it in your application as you would 
any other swing component.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
JConsole console = new JConsole();
myPanel.add(console);
</pre></td></tr></table></center><p/>

You can connect an Interpreter to the console by specifying it in the
Interpreter constructor, like so:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
Interpreter interpreter = new Interpreter( console );
new Thread( interpreter ).start(); // start a thread to call the run() method
</pre></td></tr></table></center><p/>

Or you can connect the JConsole to the Interpreter directly with 
Interpreter setConsole().  
<p CLEAR="ALL"/>

For external use, JConsole can supply a PrintWriter through its getOut() 
method and has a full suite of direct print() methods.  

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
When interacting with any Swing component from outside the Java event handling 
thread, use the Swing thread safety facilities: SwingUtilities.invokeNow() 
and invokeLater().           
</td></tr></table></center><p/>

<h2><a name="ConsoleInterface">ConsoleInterface</a></h2>

JConsole implements the bsh.ConsoleInterface interface, which defines how
the Interpreter interacts with a console object.  To the interpreter a console
is simply a set of I/O streams with some optimized print methods:

<table border="1" cellpadding="5">
<tr><td>Reader getIn();</td></tr>
<tr><td>PrintStream getOut();</td></tr>
<tr><td>PrintStream getErr();</td></tr>
<tr><td>void println( String s );</td></tr>
<tr><td>void print( String s );</td></tr>
<tr><td>void error( String s );</td></tr>
</table>

Any object that implements this interface can be attached to the Interpreter
as a GUI console.
<p CLEAR="ALL"/>

The bsh.util.GUIConsoleInterface extends the ConsoleInterface and adds
methods for printing a string with a color attribute, supplying wait 
feedback (the wait cursor) and name completion support.  JConsole implements
this interface and it is used indirectly via BeanShell commands when it
is detected.
<p CLEAR="ALL"/>

<h3>AWTConsole</h3>

The bsh.util.AWTConsole is a legacy implementation of the GUI Console using
AWT instead of Swing.  This console does work, but it is not as slick or
pretty as the JConsole.  The primary reason it is still here is to support
remote access from generic web browsers using only Java 1.1.


<hr/><!--PAGE BREAK-->

	<h1><a name="Reflective_Style_Access_to_Scripted_Methods">Reflective Style Access to Scripted Methods</a></h1>


The following examples show how to work with BeanShell methods dynamically 
from within scripts, using the equivalent of reflective style access in Java.
This is an advanced topic primarily of interest to developers who wish to
do tight integration of BeanShell scripts with their application environment.
<p CLEAR="ALL"/>

<h2><a name="eval()">eval()</a></h2>

The simplest form of reflective style access to scripts is through the 
eval() command.  With eval() you can evaluate any text just as if it had 
appeared in the current scope.  For example:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
eval("a=5;");
print( a ); // 5
</pre></td></tr></table></center><p/>

So, if you know the signature (argument types) of a method you wish to work 
with you can simply construct a method call as a string and evaluate it 
with eval() as in the following:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Declare methods foo() and bar( int, String )
foo() { ... }
bar( int arg1, String arg2 ) { ... }

// Invoke a no-args method foo() by its name using eval()
name="foo";
// invoke foo() using eval()
eval( name+"()");

// Invoke two arg method bar(arg1,arg2) by name using eval()
name="bar";
arg1=5;
arg2="stringy";
eval( name+"(arg1,arg2)");
</pre></td></tr></table></center><p/>

You can get the names of all of the methods defined in the current scope
using the 'this.methods' magic reference, which returns an array of Strings:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// Print the methods defined in this namespace
print( this.methods );
</pre></td></tr></table></center><p/>

We'll talk about more powerful forms of method lookup in a moment.

<h2><a name="invokeMethod()">invokeMethod()</a></h2>

You can explicitly invoke a method by name with arguments through a 'this' 
type reference using the invokeMethod() method:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
this.invokeMethod( "bar", new Object [] { new Integer(5), "stringy" } );
</pre></td></tr></table></center><p/>

Arguments are passed as an array of objects.  Primitive types must be 
wrapped in their appropriate wrappers.
BeanShell will select among overloaded methods using the standard Java
method resolution rules.  (JLS 15.11.2).

<h2><a name="Method_Lookup">Method Lookup</a></h2>

The previous section showed how to invoke a method by name when we know
the argument types.  Of course, in general we'd like to be able to find out
what methods are defined in the current script or to look up a method by
its signature.
<p CLEAR="ALL"/>

You can get "handles" to all of the methods defined in a context using the 
namespace getMethods() method.  
getMethods() returns an array of bsh.BshMethod objects,
which are wrappers for the internally parsed representation of BeanShell
scripted methods:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
foo() { ... }
foo( int a ) { ... }
bar( int arg1, String arg2 ) { ... }

print ( this.namespace.getMethods() );

// Array: [Lbsh.BshMethod;@291aff {
//   Bsh Method: bar
//   Bsh Method: foo
//   Bsh Method: foo
// }
</pre></td></tr></table></center><p/>

We'll talk about what you can do with a BshMethod in a moment.
<p CLEAR="ALL"/>

Alternately, you can use the namespace getMethod() method to search 
for a specific method signature.  The method signature is a set of argument 
types represented by an array of Classes:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
name="bar";
signature = new Class [] { Integer.TYPE, String.class };

// Look up a method named bar with arg types int and String
bshMethod = this.namespace.getMethod( name, signature );

print("Found method: "+bshMethod);
</pre></td></tr></table></center><p/>

<p/><center><table cellpadding="5" border="1" width="100%"><tr><td><strong>Tip:</strong><br CLEAR="ALL"/>
The Java reflection API uses special class values to represent primitive types
such as int, char, an boolean.  These types are static fields in the respective
primitive wrapper classes.  e.g. Integer.TYPE, Character.TYPE, Boolean.TYPE.
</td></tr></table></center><p/>

In the above snippet we located the bar() method by its signature.  If there
had been overloaded forms of bar() getMethod() would have located the most
specific one according to the standard Java method resolution rules 
(JLS 15.11.2).
The result of the lookup is a bsh.BshMethod object, as before.
<p CLEAR="ALL"/>

<h2><a name="BshMethod">BshMethod</a></h2>

You can inspect a BshMethod object to determine its method name and
argument types:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
name = bshMethod.getName();
Class [] types = bshMethod.getArgumentTypes();
Class returnType = bshMethod.getReturnType();
</pre></td></tr></table></center><p/>

To invoke the BshMethod, call its invoke() method, passing an array of 
arguments, an interpreter reference, and a "callstack" reference.
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
// invoke the method with arg
bshMethod.invoke( new Object [] { new Integer(1), "blah!" }, 
    this.interpreter, this.callstack );
</pre></td></tr></table></center><p/>

For the
interpreter and callstack references you can simply pass along the current
context's values via 'this.interpreter' and 'this.callstack', as we did
above.  The arguments array may be null or empty for no arguments.
<p CLEAR="ALL"/>



<h2><a name="Uses">Uses</a></h2>

Why would anyone want to do this?  Well, perhaps you are sourcing a script
created by a user and want to automatically begin using methods that they
have defined.  Perhaps the user is allowed to define methods to take control 
of various aspects of your application.  With the tools we've described
in this section you can list the methods they have defined and invoke
them dynamically.

<hr/><!--PAGE BREAK-->


	<h1><a name="Executable_scripts_under_Unix">Executable scripts under Unix</a></h1>


You can use BeanShell for writing scripts as you would any other shell 
under many Unixs:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
#!/usr/java/bin/java bsh.Interpreter 

print("foo");
</pre></td></tr></table></center><p/>

However some flavors of Unix are more picky about what they will allow
as a shell program.  For those you can use the following hack to make
your BeanShell scripts executable.

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
#!/bin/sh
# The following hack allows java to reside anywhere in the PATH.
//bin/true; exec java bsh.Interpreter "$0" "$@"

print("foo");
</pre></td></tr></table></center><p/>

The above trick presumes that /bin/true exists on your system and that //bin is
the same as /bin.  The // causes BeanShell to ignore the line.
<p CLEAR="ALL"/>

The above has been tested on Solaris.  It does not seem to work under Cygwin.

<h3>OSX</h3>

For OSX the path is a bit different:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
#!/Library/Java/home/bin/java bsh.Interpreter

print("foo");
</pre></td></tr></table></center><p/>

On OSX /usr/bin/java is itself a shell script, which unfortunately won't
work out-of-the-box.

<hr/><!--PAGE BREAK-->

	<h1><a name="BSF_Bean_Scripting_Framework">BSF Bean Scripting Framework</a></h1>


BSF is the Apache "Bean Scripting Framework".  
It is generic framework that allows
many scripting languages to be plugged into an application.  It shields
the application from knowledge of how to invoke the scripting languages and
their APIs, via adapter "engines". 
<p CLEAR="ALL"/>

BeanShell supports the BSF API by providing the necessary adapter.  
This means that BeanShell can be used as a scripting language for any BSF
2.3 capable application simply by dropping the bsh JAR file into the classpath.
<p CLEAR="ALL"/>

Prior to version 2.3, BSF was maintained by IBM.  
To get BeanShell to work with older versions of BSF you must use the 
older bsh-bsf-1.2x.jar file which includes the adapter class for the previous
ibm packaged BSF API.
You must also explicitly register the BeanShell adapter with older versions
of BSF.  Here is an example of how to do that:

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
import com.ibm.bsf.*;

// register beanshell with the BSF framework
String [] extensions = { "bsh" };
BSFManager.registerScriptingEngine(
    "beanshell", "bsh.util.BeanShellBSFEngine", extensions );
</pre></td></tr></table></center><p/>


See 
<a href="http://jakarta.apache.org/bsf/">http://jakarta.apache.org/bsf/</a> 
and
<a href="http://oss.software.ibm.com/developerworks/projects/bsf">
http://oss.software.ibm.com/developerworks/projects/bsf</a> 

for more information about BSF.

<h2><a name="Ant">Ant</a></h2>

<em>This section needs to be updated.  I'm not sure what versionf of Ant use
the new and which use the old BSF API.</em>
<p CLEAR="ALL"/>

Ant 1.5+ has explicit support for BeanShell as a BSF scripting language.
The BeanShell JAR file includes the necessary BSF adapter.  You must
simply specify language="beanshell" in your script tags.

<h3>Installation</h3>

To use BeanShell within Ant you must do two things:
<ol>
<li>Add the
<a href="http://oss.software.ibm.com/developerworks/projects/bsf">
BSF bsf.jar file</a>
to ANT_HOME/lib or the classpath.</li>
<li>Add the 
<a href="http://www.beanshell.org/download.html">
BeanShell bsh.jar file</a>
to ANT_HOME/lib or the classpath.</li>
</ol>
<p CLEAR="ALL"/>

You can then run scripts from a file, or in-line like so:
<p CLEAR="ALL"/>

<p/><center><table border="1" cellpadding="5" width="100%"><tr><td bgcolor="#dfdfdc"><pre>
&lt;project name="testbsh" default="runscript" basedir="."&gt;
    &lt;target name="runscript"&gt;

        &lt;!-- Run script from a file --&gt;
        &lt;script language="beanshell" src="myscript.bsh"/&gt;

        &lt;!-- Run script in-line --&gt;
        &lt;script language="beanshell"&gt;&amp;lt;![CDATA[
            for(int i=0; i&lt;10; i++ )
                print( "i="+i );
        ]]&amp;gt;&lt;/script&gt;

    &lt;/target&gt;
&lt;/project&gt;
</pre></td></tr></table></center><p/>


<hr/><!--PAGE BREAK-->

	<h1><a name="Learning_More">Learning More</a></h1>


BeanShell is a simple tool but one with rapidly evolving capabilities.  To learn
more about BeanShell you are highly encouraged to download the source and
build it (using the Ant build file).  Even if you don't consider yourself
a developer, you can learn a lot from the source distribution by looking
at the implementation of the standard BeanShell commands and the test suite.
<p CLEAR="ALL"/>

Almost all of the built-in BeanShell commands are simply scripts
stored in the BeanShell JAR file under the path "bsh/commands".  
A good way to familiarize yourself with more of BeanShell is to take a look 
at those commands.  Simply unpack bsh/commands/*.bsh from the JAR file.
The BeanShell test suite consists of many BeanShell scripts that exercise
all parts of the language.
<p CLEAR="ALL"/>

In addition to the mailing list and mailing list archives, an important
source of information is the "recent changes" file supplied with the source
distribution and online at: http://www.beanshell.org/Changes.html.  This
file is one of the few documents that is always up to date with the latest
release (smile).

<h2><a name="Helping_With_the_Project">Helping With the Project</a></h2>

BeanShell is an open source project which relies on people like you to
get things done.  If you are excited about BeanShell there is undoubtedly
some way for you to help.  If you are a developer, there is always work
(sometimes boring, sometimes not) to be done.  If you are not a developer
you may still be able to help by writing new tests for the test suite, or
working on the documentation, web site, tutorials or examples.
<p CLEAR="ALL"/>

Here are some things that we can always use help with:

<ul>
<li><strong>Tests for the test suite</strong> - We need more tests!  
BeanShell relies heavily on its test suite to guarantee that changes don't
break subtle aspects of the language.  Often tests are added for specific
bug cases (Developers: please add a test for any bug you fix!).  But it would
be best if tests were generalized to cover all of the "corner cases" too.</li>

<li><strong>Bug fixes</strong> - Check the bugs list at the sourceforge site and dig into
the code.  Some bug fixes are easy, some are deep.  Feel free to contact
me (pat@pat.net) directly if you want help getting started on an issue.</li>

<li>
<strong>Docs</strong> - We can always use articles, documentation and examples.
</li>

<li>
<strong>Integration and third party tools</strong> - Have you integrated
BeanShell into another tool or environment?  Let us know and we'll link
to your site.
</li>

<li>
<strong>Feedback from the World</strong> - Despite BeanShell's relative
popularity you would be amazed at how little information we have about 
who is using the tool and how.   If you are using it or you know people using 
it please let us know!
</li>

</ul>

<hr/><!--PAGE BREAK-->

	<h1><a name="Credit_and_Acknowledgments">Credit and Acknowledgments</a></h1>


Many people have contributed substantially to BeanShell over the years.
I will attempt to start crediting those individual here.  Please do not be 
offended if your name is missing.  This list will grow as I have time to
work backwards through my email and recover names. 
<p CLEAR="ALL"/>

<ul>
<li>Thanks to Daniel Leuck for his long time support and many contributions
to the project.</li>
</ul>

<h3>Me</h3>

Finally, I will put in a plug for myself:
Pat Niemeyer (pat@pat.net)
<p CLEAR="ALL"/>

<img src="../images/lj.gif"/>
If you like BeanShell check out my book:

<a href="http://www.ora.com/catalog/learnjava2/">
Learning Java, O'Reilly &amp; Associates, 2nd edition</a>.
<br clear="left"/>
<p CLEAR="ALL"/>

Winner of the Best Java Introductory Book - JavaOne 2001.  Learning Java
(previously titled Exploring Java) is available in nine languages world-wide.

It is a comprehensive overview of the Java language and APIs including
a brief introduction to BeanShell as well! 
<p CLEAR="ALL"/>

<h2><a name="License_and_Terms_of_Use">License and Terms of Use</a></h2>

You may freely use and reproduce this document in its entirety as long as 
you preserve this license information and a pointer to the original
web site: http://www.beanshell.org.  You may integrate parts of this document
into your own documentation as long as you provide this same information 
at an appropriate place in your document.
<p CLEAR="ALL"/>

This document is copyright Pat Niemeyer, 2002.  Sections contributed by
other authors are copyrighted to those individuals and subject to the
terms of use described above.
<p CLEAR="ALL"/>

<hr/><!--PAGE BREAK-->

	<h1><a name="BeanShell_Commands_Documentation">BeanShell Commands Documentation</a></h1>
	

The following documentation was generated automatically by 'BshDoc' from 
Javadoc style comments in the BeanShell command script files.  See "BshDoc"
for more information.
<p CLEAR="ALL"/>


<?xml-stylesheet type="text/xsl" href="bshcommands.xsl"?>
<!-- This file was auto-generated by the bshdoc.bsh script -->
<p/><table width="100%" border="1" cellpadding="2"><tr><td width="20%"><strong><a href="#addClassPath">addClassPath</a></strong></td><td>void addClassPath( string | URL )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#bg">bg</a></strong></td><td>Thread bg( String filename )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#bind">bind</a></strong></td><td>bind ( bsh .This ths , bsh .NameSpace namespace ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#browseClass">browseClass</a></strong></td><td>void browseClass( String | Object | Class )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#cat">cat</a></strong></td><td>cat ( String filename ) <br CLEAR="ALL"/>cat ( URL url ) <br CLEAR="ALL"/>cat ( InputStream ins ) <br CLEAR="ALL"/>cat ( Reader reader ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#cd">cd</a></strong></td><td>void cd ( String pathname ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#classBrowser">classBrowser</a></strong></td><td>classBrowser ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#clear">clear</a></strong></td><td>clear ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#cp">cp</a></strong></td><td>cp ( String fromFile , String toFile ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#debug">debug</a></strong></td><td>debug ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#desktop">desktop</a></strong></td><td>desktop ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#dirname">dirname</a></strong></td><td>String dirname ( String pathname ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#editor">editor</a></strong></td><td>editor ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#error">error</a></strong></td><td>void error ( item ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#eval">eval</a></strong></td><td>Object eval ( String expression ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#exec">exec</a></strong></td><td>exec ( String arg ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#exit">exit</a></strong></td><td>exit ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#extend">extend</a></strong></td><td>This extend( This object )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#fontMenu">fontMenu</a></strong></td><td>fontMenu ( component ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#frame">frame</a></strong></td><td>Frame | JFrame | JInternalFrame frame( Component component )

<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getBshPrompt">getBshPrompt</a></strong></td><td>String getBshPrompt ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getClass">getClass</a></strong></td><td>Class getClass ( String name ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getClassPath">getClassPath</a></strong></td><td>URL [ ] getClassPath ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getResource">getResource</a></strong></td><td>URL getResource ( String path ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#getSourceFileInfo">getSourceFileInfo</a></strong></td><td>getSourceFileInfo ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#importCommands">importCommands</a></strong></td><td>void importCommands( resource path | package name )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#importObject">importObject</a></strong></td><td>void importObject( Object object )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#javap">javap</a></strong></td><td>void javap( String | Object | Class | ClassIdentifier )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#load">load</a></strong></td><td>Object load ( String filename ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#makeWorkspace">makeWorkspace</a></strong></td><td>makeWorkspace ( String name ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#mv">mv</a></strong></td><td>mv ( String fromFile , String toFile ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#object">object</a></strong></td><td>This object()
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#pathToFile">pathToFile</a></strong></td><td>File pathToFile ( String filename ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#print">print</a></strong></td><td>void print ( arg ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#printBanner">printBanner</a></strong></td><td>printBanner ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#pwd">pwd</a></strong></td><td>pwd ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#reloadClasses">reloadClasses</a></strong></td><td>void reloadClasses( [ package name ] )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#rm">rm</a></strong></td><td>boolean rm ( String pathname ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#run">run</a></strong></td><td>run ( String filename , Object runArgument ) <br CLEAR="ALL"/>run ( String filename ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#save">save</a></strong></td><td>void save ( Object obj , String filename ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#server">server</a></strong></td><td>void server ( int port ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setAccessibility">setAccessibility</a></strong></td><td>setAccessibility ( boolean b ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setClassPath">setClassPath</a></strong></td><td>void setClassPath( URL [] )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setFont">setFont</a></strong></td><td>Font setFont ( Component comp , String family , int style , int size ) <br CLEAR="ALL"/>Font setFont ( Component comp , int size ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setNameCompletion">setNameCompletion</a></strong></td><td>void setNameCompletion ( boolean bool ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setNameSpace">setNameSpace</a></strong></td><td>setNameSpace ( ns ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#setStrictJava">setStrictJava</a></strong></td><td>void setStrictJava ( boolean val ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#show">show</a></strong></td><td>show ( ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#source">source</a></strong></td><td>Object source ( String filename ) <br CLEAR="ALL"/>Object source ( URL url ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#sourceRelative">sourceRelative</a></strong></td><td>sourceRelative ( String file ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#thinBorder">thinBorder</a></strong></td><td>public thinBorder ( ) <br CLEAR="ALL"/>public thinBorder ( Color lightColor , Color darkColor ) <br CLEAR="ALL"/>public thinBorder ( Color lightColor , Color darkColor , boolean rollOver ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#unset">unset</a></strong></td><td>void unset ( String name ) <br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#which">which</a></strong></td><td>which( classIdentifier | string | class )
<br CLEAR="ALL"/></td></tr><tr><td width="20%"><strong><a href="#workspaceEditor">workspaceEditor</a></strong></td><td>workspaceEditor ( Interpreter parent , String name ) <br CLEAR="ALL"/></td></tr></table><p/><!--PAGE BREAK--><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="addClassPath"><strong><font size="+2">addClassPath</font></strong></a><br CLEAR="ALL"/><font size="+1">void addClassPath( string | URL )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Add the specified directory or JAR file to the class path.
	e.g.
	<p>
	<pre>
    addClassPath( "/home/pat/java/classes" );
    addClassPath( "/home/pat/java/mystuff.jar" );
    addClassPath( new URL("http://myserver/~pat/somebeans.jar") );
	</pre>
	<p>
	See <a href="classpath.html">Class Path Management</a>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="bg"><strong><font size="+2">bg</font></strong></a><br CLEAR="ALL"/><font size="+1">Thread bg( String filename )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Source a command in its own thread in the caller's namespace
	<p>

	This is like run() except that it runs the command in its own thread.  
	Returns the Thread object control.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="bind"><strong><font size="+2">bind</font></strong></a><br CLEAR="ALL"/><font size="+1">bind ( bsh .This ths , bsh .NameSpace namespace ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Bind a bsh object into a particular namespace and interpreter

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="browseClass"><strong><font size="+2">browseClass</font></strong></a><br CLEAR="ALL"/><font size="+1">void browseClass( String | Object | Class )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Open the class browser to view the specified class.  
	If the argument is a string it is considered to be a class name.  
	If the argument is an object, the class of the object is used.  
	If the arg is a class, the class is used.
	<p>

	Note: To browse the String class you can't supply a String.
	You'd have to do:  browseClass( String.class );
	<p>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="cat"><strong><font size="+2">cat</font></strong></a><br CLEAR="ALL"/><font size="+1">cat ( String filename ) <br CLEAR="ALL"/>cat ( URL url ) <br CLEAR="ALL"/>cat ( InputStream ins ) <br CLEAR="ALL"/>cat ( Reader reader ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the contents of filename, url, or stream (like Unix cat)

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="cd"><strong><font size="+2">cd</font></strong></a><br CLEAR="ALL"/><font size="+1">void cd ( String pathname ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Change working directory for dir(), etc. commands (like Unix cd)

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="classBrowser"><strong><font size="+2">classBrowser</font></strong></a><br CLEAR="ALL"/><font size="+1">classBrowser ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Open the class browser.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="clear"><strong><font size="+2">clear</font></strong></a><br CLEAR="ALL"/><font size="+1">clear ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Clear all variables, methods, and imports from this namespace.
	If this namespace is the root, it will be reset to the default 
	imports.
	See NameSpace.clear();
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="cp"><strong><font size="+2">cp</font></strong></a><br CLEAR="ALL"/><font size="+1">cp ( String fromFile , String toFile ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Copy a file (like Unix cp).

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="debug"><strong><font size="+2">debug</font></strong></a><br CLEAR="ALL"/><font size="+1">debug ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Toggle on and off debug mode. 
	Debug output is verbose and generally useful only for developers.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="desktop"><strong><font size="+2">desktop</font></strong></a><br CLEAR="ALL"/><font size="+1">desktop ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
 * Start the BeanShell GUI desktop in a JFrame.  A starter workspace is created
 * and added to the desktop.
 *
 * @method void desktop()
 *
 * @author Pat Niemeyer
 * @author Daniel Leuck
 
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="dirname"><strong><font size="+2">dirname</font></strong></a><br CLEAR="ALL"/><font size="+1">String dirname ( String pathname ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Return directory portion of path based on the system default file separator.
	Note: you should probably use pathToFile() to localize the path relative
	to BeanShell's working directory and then file.getAbsolutePath() to get
	back to a system localized string.
	<p>
	
	Example: to change to the directory that contains the script we're 
	currently executing:

	<pre>
	// Change to the directory containing this script
	path=pathToFile( getSourceFileInfo() ).getAbsolutePath();
	cd( dirname( path ) );
	</pre>

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="editor"><strong><font size="+2">editor</font></strong></a><br CLEAR="ALL"/><font size="+1">editor ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Open a GUI editor from the command line or in the GUI desktop mode.
	When run from the command line the editor is a simple standalone
	frame.  When run inside the GUI desktop it is a workspace editor.
	See workspaceEditor()

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="error"><strong><font size="+2">error</font></strong></a><br CLEAR="ALL"/><font size="+1">void error ( item ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the item as an error.  
	In the GUI console the text will show up in (something like) red, 
	else it will be printed to standard error.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="eval"><strong><font size="+2">eval</font></strong></a><br CLEAR="ALL"/><font size="+1">Object eval ( String expression ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Evaluate the string in the current interpreter (see source()).
	Returns the result of the evaluation or null.
	<p>

	Evaluate a string as if it were written directly in the current scope, 
	with side effects in the current scope.
	<p>
	e.g.
    <code><pre>
    a=5;
    eval("b=a*2");
    print(b); // 10
    </pre></code>
	<p>

	eval() acts just like invoked text except that any exceptions generated
	by the code are captured in a bsh.EvalError.  This includes ParseException
	for syntactic errors and TargetError for exceptions thrown by the evaluated
	code.
	<p>
	e.g.
    <pre>
    try {
        eval("foo>>><>M>JK$LJLK$");
    } catch ( EvalError e ) {
        // ParseException caught here
    }

    try {
        eval("(Integer)true");  // illegal cast
    } catch ( EvalError e ) {
        // TargetException caught here
        print( e.getTarget() )  // prints ClassCastException
    }
    </pre>
	<p>
	
	If you want eval() to throw target exceptions directly, without wrapping
	them, you can simply redefine own eval like so:

    <pre>
    myEval( String expression ) {
        try {
            return eval( expression );
        } catch ( TargetError e ) {
            throw e.getTarget();
        }
    }
    </pre>
	<p/>

	Here is a cute example of how to use eval to implement a dynamic cast.  
	i.e. to cast a script to an arbitrary type by name at run-time where the
	type is not known when you are writing the script.  In this case the type
	is in the variable interfaceType.
	<pre>
    reference = eval( "("+interfaceType+")this" );
	</pre>

	<p>
	Returns the value of the expression.
	<p>
	Throws bsh.EvalError on error
	<p>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="exec"><strong><font size="+2">exec</font></strong></a><br CLEAR="ALL"/><font size="+1">exec ( String arg ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Start an external application using the Java Runtime exec() method.
	Display any output to the standard BeanShell output using print().

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="exit"><strong><font size="+2">exit</font></strong></a><br CLEAR="ALL"/><font size="+1">exit ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Conditionally exit the virtual machine.
	Call System.exit(0) unless bsh.system.shutdownOnExit == false.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="extend"><strong><font size="+2">extend</font></strong></a><br CLEAR="ALL"/><font size="+1">This extend( This object )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Return a new object that is a child of the specified object.
	<strong>
	Note: this command will likely change along with a better inheritance 
	mechanism for bsh in a future release.</strong>
	<p>

	extend() is like the object() command, which
	creates a new bsh scripted object, except that the namespace of
	the new object is a child of the parent object. 
	<p>

	For example:
	<p>

    <pre>
    foo=object();
    bar=extend(foo);

    is equivalent to:
      
    foo() { 
        bar() {
            return this; 
        }
    }

    foo=foo();
    bar=foo.bar();

    and also:
     
    oo=object();
    ar=object();
    ar.namespace.bind( foo.namespace );
    </pre>
	<p>

	The last example above is exactly what the extend() command does.
	In each case the bar object inherits variables from foo in the usual way.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="fontMenu"><strong><font size="+2">fontMenu</font></strong></a><br CLEAR="ALL"/><font size="+1">fontMenu ( component ) <br CLEAR="ALL"/></font></td></tr><tr><td>
 * Creates a font menu for use with the workspace and workspace editors
 *
 * @return a font menu
 *
 * @author Daniel Leuck
 
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="frame"><strong><font size="+2">frame</font></strong></a><br CLEAR="ALL"/><font size="+1">Frame | JFrame | JInternalFrame frame( Component component )

<br CLEAR="ALL"/></font></td></tr><tr><td>
    Show component in a frame, centered and packed, handling disposal with
	the close button.
	<p>

	Display the component, centered and packed, in a Frame, JFrame, or 
	JInternalFrame.  Returns the frame.  If the GUI desktop is running then a 
	JInternaFrame will be used and automatically added to the desktop.  
	Otherwise if Swing is available a top level JFrame will be created.  
	Otherwise a plain AWT Frame will be created.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getBshPrompt"><strong><font size="+2">getBshPrompt</font></strong></a><br CLEAR="ALL"/><font size="+1">String getBshPrompt ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Get the value to display for the bsh interactive prompt.
	This command checks for the variable bsh.prompt and uses it if set.
	else returns "bsh % "
	<p/>
	Remember that you can override bsh commands simply by defining the method
	in your namespace. e.g. the following method displays the current working
	directory in your prompt:
	<p/>
	<pre>
	String getBshPrompt() {
		return bsh.cwd + " % ";
	}
	</pre>

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getClass"><strong><font size="+2">getClass</font></strong></a><br CLEAR="ALL"/><font size="+1">Class getClass ( String name ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Get a class through the current namespace utilizing the current imports,
	extended classloader, etc.
	<p>

	This is equivalent to the standard Class.forName() method for class loading,
	however it takes advantage of the BeanShell class manager so that added 
	classpath will be taken into account.  You can also use Class.forName(), 
	however if you have modified the classpath or reloaded classes from within 
	your script the modifications will only appear if you use the getClass() 
	command.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getClassPath"><strong><font size="+2">getClassPath</font></strong></a><br CLEAR="ALL"/><font size="+1">URL [ ] getClassPath ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
    Get the current classpath including all user path, extended path, and the
    bootstrap JAR file if possible.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getResource"><strong><font size="+2">getResource</font></strong></a><br CLEAR="ALL"/><font size="+1">URL getResource ( String path ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Get a resource from the BeanShell classpath.
	This method takes into account modification to the BeanShell class path via
	addClassPath() and setClassPath();

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="getSourceFileInfo"><strong><font size="+2">getSourceFileInfo</font></strong></a><br CLEAR="ALL"/><font size="+1">getSourceFileInfo ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Return the name of the file or source from which the current interpreter
	is reading.  Note that if you use this within a method, the result will
	not be the file from which the method was sourced, but will be the file 
	that the caller of the method is reading.   Methods are sourced once but
	can be called many times... Each time the interpreter may be associated
	with a different file and it is that calling interpreter that you are
	asking for information.
	<p>

	Note: although it may seems like this command would always return the
	getSourceFileInfo.bsh file, it does not since it is being executed after
	sourcing by the caller's interpreter.
	If one wanted to know the file from which a bsh method was sourced one
	would have to either capture that info when the file was sourced (by
	saving the state of the getSourceFileInfo() in a variable outside of
	the method or more generally we could add the info to the BshMethod class
	so that bsh methods remember from what source they were created...

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="importCommands"><strong><font size="+2">importCommands</font></strong></a><br CLEAR="ALL"/><font size="+1">void importCommands( resource path | package name )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Import scripted or compiled BeanShell commands in the following package
	in the classpath.  You may use either "/" path or "." package notation.
	e.g. 
	<pre>
		// equivalent
		importCommands("/bsh/commands")
		importCommands("bsh.commands")
	<pre>

	When searching for a command each path will be checked for first, a file
	named 'command'.bsh and second a class file named 'command'.class.
	<p/>

	You may add to the BeanShell classpath using the addClassPath() or
	setClassPath() commands and then import them as usual.
	<pre>
		addClassPath("mycommands.jar");
		importCommands("/mypackage/commands");
	</pre>
	<p/>

	If a relative path style specifier is used then it is made into an absolute
	path by prepending "/".  Later imports take precedence over earlier ones.
	<p/>

	Imported commands are scoped just like imported clases.
	<p/>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="importObject"><strong><font size="+2">importObject</font></strong></a><br CLEAR="ALL"/><font size="+1">void importObject( Object object )
<br CLEAR="ALL"/></font></td></tr><tr><td>
    Import an instance object into this namespace
    (analogous to static class imports).
    You can import the methods and fields of a Java object instance into
    a BeanShell namespace.  e.g.

    <pre>
        Map map = new HashMap();
        importObject( map );
        put("foo", "bar");
        print( get("foo") ); // "bar"
    </pre>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="javap"><strong><font size="+2">javap</font></strong></a><br CLEAR="ALL"/><font size="+1">void javap( String | Object | Class | ClassIdentifier )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the public fields and methods of the specified class (output similar 
	to the JDK javap command).
	<p/>
	If the argument is a string it is considered to be a class name.  If the
	argument is an object, the class of the object is used.  If the arg is a
	class, the class is used.  If the argument is a class identifier, the class
	identified by the class identifier will be used. e.g.  If the argument is
	the empty string an error will be printed.
	<p/>
	<pre>
	// equivalent
	javap( java.util.Date ); // class identifier
	javap( java.util.Date.class ); // class
	javap( "java.util.Date" ); // String name of class
	javap( new java.util.Date() ); // instance of class
	</pre>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="load"><strong><font size="+2">load</font></strong></a><br CLEAR="ALL"/><font size="+1">Object load ( String filename ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Load a serialized Java object from filename.  Returns the object.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="makeWorkspace"><strong><font size="+2">makeWorkspace</font></strong></a><br CLEAR="ALL"/><font size="+1">makeWorkspace ( String name ) <br CLEAR="ALL"/></font></td></tr><tr><td>
 * Creates a JConsole in a JInternalFrame and adds it to the desktop 
 *
 * @return this (the workspace scripted object for allowing access to the 
 *          frame, interpreter, etc.)
 *
 * @author Pat Niemeyer
 * @author Daniel Leuck (bug fixes)
 
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="mv"><strong><font size="+2">mv</font></strong></a><br CLEAR="ALL"/><font size="+1">mv ( String fromFile , String toFile ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Rename a file (like Unix mv).

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="object"><strong><font size="+2">object</font></strong></a><br CLEAR="ALL"/><font size="+1">This object()
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Return an "empty" BeanShell object context which can be used to hold 
	data items.  e.g. 
	<p>
	<pre>
    myStuff = object();
    myStuff.foo = 42;
    myStuff.bar = "blah";
	</pre>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="pathToFile"><strong><font size="+2">pathToFile</font></strong></a><br CLEAR="ALL"/><font size="+1">File pathToFile ( String filename ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Create a File object corresponding to the specified file path name, taking
	into account the bsh current working directory (bsh.cwd)

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="print"><strong><font size="+2">print</font></strong></a><br CLEAR="ALL"/><font size="+1">void print ( arg ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the string value of the argument, which may be of any type.
	If beanshell is running interactively, the output will always go to the 
	command line, otherwise it will go to System.out.
	<p>

	Most often the printed value of an object will simply be the Java 
	toString() of the object.  However if the argument is an array the contents 
	of the array will be (recursively) listed in a verbose way.
	<p>

	Note that you are always free to use System.out.println() 
	instead of print().

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="printBanner"><strong><font size="+2">printBanner</font></strong></a><br CLEAR="ALL"/><font size="+1">printBanner ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the BeanShell banner (version and author line) - GUI or non GUI.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="pwd"><strong><font size="+2">pwd</font></strong></a><br CLEAR="ALL"/><font size="+1">pwd ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Print the BeanShell working directory.  This is the cwd obeyed by all the 
	unix-like bsh commands.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="reloadClasses"><strong><font size="+2">reloadClasses</font></strong></a><br CLEAR="ALL"/><font size="+1">void reloadClasses( [ package name ] )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Reload the specified class, package name, or all classes if no name is 
	given.  e.g.
	<p>

	<pre>
    reloadClasses();
    reloadClasses("mypackage.*");
    reloadClasses(".*")  // reload unpackaged classes
    reloadClasses("mypackage.MyClass") 
	</pre>
	<p>

	See "Class Path Management"
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="rm"><strong><font size="+2">rm</font></strong></a><br CLEAR="ALL"/><font size="+1">boolean rm ( String pathname ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Remove a file (like Unix rm).

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="run"><strong><font size="+2">run</font></strong></a><br CLEAR="ALL"/><font size="+1">run ( String filename , Object runArgument ) <br CLEAR="ALL"/>run ( String filename ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Run a command in its own in its own private global namespace, with its
	own class manager and interpeter context.  (kind of like unix "chroot" for 
	a namespace).
	The root bsh system object is extended (with the extend() command) and 
	made visible here, so that general system info (e.g. current working
	directory) is effectively inherited.  Because the root bsh object is 
	extended it is effectively read only / copy on write...  
	e.g. you can change directories in the child context, do imports, change
	the classpath, etc. and it will not affect the calling context.
	<p>

	run() is like source() except that it runs the command in a new, 
	subordinate and prune()'d namespace.  So it's like "running" a command 
	instead of "sourcing" it.  run() teturns the object context in which the 
	command was run.
	<p>

	Returns the object context so that you can gather results.
	<p>
	Parameter runArgument an argument passed to the child context under the
		name runArgument.  e.g. you might pass in the calling This context
		from which to draw variables, etc.
	<p>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="save"><strong><font size="+2">save</font></strong></a><br CLEAR="ALL"/><font size="+1">void save ( Object obj , String filename ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Save a serializable Java object to filename. 

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="server"><strong><font size="+2">server</font></strong></a><br CLEAR="ALL"/><font size="+1">void server ( int port ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Create a remote BeanShell listener service attached to 
	the current interpreter, listening on the specified port.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setAccessibility"><strong><font size="+2">setAccessibility</font></strong></a><br CLEAR="ALL"/><font size="+1">setAccessibility ( boolean b ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Setting accessibility on enables to private and other non-public
	fields and method.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setClassPath"><strong><font size="+2">setClassPath</font></strong></a><br CLEAR="ALL"/><font size="+1">void setClassPath( URL [] )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Change the classpath to the specified array of directories and/or archives.
	<p>
	See "Class Path Management" for details.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setFont"><strong><font size="+2">setFont</font></strong></a><br CLEAR="ALL"/><font size="+1">Font setFont ( Component comp , String family , int style , int size ) <br CLEAR="ALL"/>Font setFont ( Component comp , int size ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Change the point size of the font on the specified component, to ptsize.
	This is just a convenience for playing with GUI components.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setNameCompletion"><strong><font size="+2">setNameCompletion</font></strong></a><br CLEAR="ALL"/><font size="+1">void setNameCompletion ( boolean bool ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Allow users to turn off name completion.
	<p>
	Turn name completion in the GUI console on or off.
	Name competion is on by default.  Explicitly setting it to true however can
	be used to prompt bsh to read the classpath and provide immediate feedback.
	(Otherwise this may happen behind the scenes the first time name completion
	is attempted).  Setting it to false will disable name completion.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setNameSpace"><strong><font size="+2">setNameSpace</font></strong></a><br CLEAR="ALL"/><font size="+1">setNameSpace ( ns ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Set the namespace (context) of the current scope.
	<p/>

	The following example illustrates swapping the current namespace.
	<p/>

	<pre>
    fooState = object(); 
    barState = object(); 
    
    print(this.namespace);
    setNameSpace(fooState.namespace);
    print(this.namespace);
    a=5;
    setNameSpace(barState.namespace);
    print(this.namespace);
    a=6;
    
    setNameSpace(fooState.namespace);
    print(this.namespace);
    print(a);  // 5
    
    setNameSpace(barState.namespace);
    print(this.namespace);
    print(a); // 6
    </pre>
	<p/>

	You could use this to creates the effect of a static namespace for a
	method by explicitly setting the namespace upon entry.
	<p/>

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="setStrictJava"><strong><font size="+2">setStrictJava</font></strong></a><br CLEAR="ALL"/><font size="+1">void setStrictJava ( boolean val ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Enable or disable "Strict Java Mode".
	When strict Java mode is enabled BeanShell will:
	<p>

	<ol>
	<li>Require typed variable declarations, method arguments and return types.
	<li>Modify the scoping of variables to look for the variable
	declaration first in the parent namespace, as in a java method inside 
	a java class.  e.g. if you can write a method called incrementFoo() that 
	will do the expected thing without referring to "super.foo".
	</ul>
	<p/>

	See "Strict Java Mode" for more details.
	<p/>

	<em>Note: Currently most standard BeanShell commands will not work in 
	Strict Java mode simply because they have not been written with full
	types, etc.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="show"><strong><font size="+2">show</font></strong></a><br CLEAR="ALL"/><font size="+1">show ( ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Toggle on or off displaying the results of expressions (off by default).
	When show mode is on bsh will print() the value returned by each expression 
	you type on the command line.

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="source"><strong><font size="+2">source</font></strong></a><br CLEAR="ALL"/><font size="+1">Object source ( String filename ) <br CLEAR="ALL"/>Object source ( URL url ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	Read filename into the interpreter and evaluate it in the current
	namespace.  Like the Bourne Shell "." command.
	This command acts exactly like the eval() command but reads from a file 
	or URL source.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="sourceRelative"><strong><font size="+2">sourceRelative</font></strong></a><br CLEAR="ALL"/><font size="+1">sourceRelative ( String file ) <br CLEAR="ALL"/></font></td></tr><tr><td>
    Source a file relative to the callering script's directory.
	<p/>

    e.g. scripts A running in dir A sources script B in dir B.
	Script B can use this command to load additional scripts (data, etc.)
	relative to its own location (dir B) without having to explicitly know 
	its "home" directory (B).
	<p/>
	Note: this only works for files currently.
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="thinBorder"><strong><font size="+2">thinBorder</font></strong></a><br CLEAR="ALL"/><font size="+1">public thinBorder ( ) <br CLEAR="ALL"/>public thinBorder ( Color lightColor , Color darkColor ) <br CLEAR="ALL"/>public thinBorder ( Color lightColor , Color darkColor , boolean rollOver ) <br CLEAR="ALL"/></font></td></tr><tr><td> 
 * A one pixel wide bevel border.  This border works for buttons (with optional
 * rollover) and other components
 *
 * @author Daniel Leuck
 
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="unset"><strong><font size="+2">unset</font></strong></a><br CLEAR="ALL"/><font size="+1">void unset ( String name ) <br CLEAR="ALL"/></font></td></tr><tr><td>
	"Undefine" the variable specifed by 'name' (So that it tests == void).
	<p>
	<em>Note: there will be a better way to do this in the future.  This is 
	currently equivalent to doing namespace.setVariable(name, null);</em>

</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="which"><strong><font size="+2">which</font></strong></a><br CLEAR="ALL"/><font size="+1">which( classIdentifier | string | class )
<br CLEAR="ALL"/></font></td></tr><tr><td>
	Use classpath mapping to determine the source of the specified class
	file.  (Like the Unix which command for executables).
	<p/>

    This command maps the entire classpath and prints all of the occurrences
    of the class.  If you just want to find the first occurrence in the
    classpath (the one that will be used by Java) you can also get it by
    printing the URL of the resource. e.g.:
	<p/>

    <pre>
        print( getResource("/com/foo/MyClass.class") );
		// Same as...
        // System.out.println(
        //    getClass().getResourceAsStream("/com/foo/MyClass.class" ) );
    </pre>
	<p/>

	Note: This is all a lie! This command is broken and only reports the
	currently first occurence! To be fixed!
	<p/>
</td></tr></table><table width="100%" border="0" cellpadding="5"><tr><td bgcolor="#cccccc"><a name="workspaceEditor"><strong><font size="+2">workspaceEditor</font></strong></a><br CLEAR="ALL"/><font size="+1">workspaceEditor ( Interpreter parent , String name ) <br CLEAR="ALL"/></font></td></tr><tr><td>
 * Make a new workspaceEditor associated with a workspace and place it on the
 * desktop.
 *
 * @method workspaceEditor( bsh.Interpreter parent, String name )
 *
 * @author Pat Niemeyer
 * @author Daniel Leuck
 
</td></tr></table>

<hr/><!--PAGE BREAK-->

 <!-- bshdoc auto generated bsh commands documentation -->
</body></html>
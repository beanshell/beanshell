<section>
<name>Methods</name>

You can define define methods in bsh, just as they would appear in Java:
<example>
    int addTwoNumbers( int a, int b ) {
        return a + b;
    }
</example>

and use them immediately as you would any bsh command:
<example>
    sum = addTwoNumbers( 5, 7 );
</example>

Just as bsh variables may be dynamically typed, bsh methods may have 
dynamic argument and return types.  We could, for example, have declared
our method like so:

<example>
    add( a, b ) {
        return a + b;
    }
</example>

In this case, bsh would dynamically determine the types when the method is
called and "do the right thing":

<example>
    foo = add(1, 2);
    print( foo ); // 3

    foo = add("Oh", " baby");
    print( foo ); // Oh baby
</example>

In the first case Java performed arithmetic addition on the integers 1 and 2.
By the way, if we had passed in numbers of other types bsh would have performed
the appropriate numeric promotion and returned the right type.  In the second
case bsh performed the usual string concatenation for String types and
returned a String object.
<p/>

Methods with unspecified return types may return any type of object (as in
the previous example).
Alternatively they may also simply issue a "return;" without a value, in
which case the effective type of the method is "void" (no type).  In 
either case, the return statement is optional.  If the method does not 
perform an explicit "return" statement, the value of the last statement or 
expression in the method body becomes the return value (and must adhere
to any declared return typing).
<p/>

<note>
The namespaces for methods and variables are separate, so
it is ok to have a method named "foo()" and variable named "foo" within
the same scope.
</note>
<p/>

<h2>
Scope modifiers: this, super, global
</h2>
<p/>

Within a method, it is possible to explicitly qualify a variable or 
method reference
with the values 'this', 'super', and 'global' to refer to, respectively,
the current scope, the calling method's scope, or the global scope.

<example>
    a = 42;
    foo() {
        a = 97;
        print( a );
        print( this.a );
        print( super.a );
    }

    foo();  // prints 97, 97, 42
</example>

In the case above, 'global' and 'super' both refer to the top level scope.
<p/>
We'll refer to instances of the special 'this', 'super', and 'global' 
references as "This" type references.  
<p/>

</section>

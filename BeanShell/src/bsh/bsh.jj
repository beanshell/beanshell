/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. bsh.jj */
/*@egen*//*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  BeanShell is distributed under the terms of the LGPL:                    *
 *  GNU Library Public License http://www.gnu.org/copyleft/lgpl.html         *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Exploring Java, O'Reilly & Associates                          *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/

options {
    JAVA_UNICODE_ESCAPE=true;
    STATIC=false;                                                                                       
}

PARSER_BEGIN(Interpreter)
package bsh;

import java.util.Vector;
import java.io.*;
import java.awt.Color;

/**
	The BeanShell script interpreter.

	An instance of Interpreter or Server can be used to source scripts
	and evaluate expressions.  Some examples:

<p><blockquote><pre>
		// Evaluate expressions
		Interpeter i = new Interpreter();
		i.eval("foo=5");
		i.eval("bar=foo*5);

		// Source from files
		i.source("myscript.bsh");  // or i.eval("source(\"myscript.bsh\")");

		// Pass in an object as a variable
		i.setVariable( "date", new Date() );
		i.eval("year = date.getYear()");

		// Fetch script as an arbitrary interface 
		i.eval(	"foo() { print( date ); }");
		MyInterface myObj = (MyInterface)i.eval("return (MyInterface)this");
		myObj.foo();
</pre></blockquote>

	See the BeanShell User's Manual for more information.
*/
public class Interpreter implements/*@bgen(jjtree)*/ InterpreterTreeConstants, /*@egen*/ Runnable /*,Serializable*/ 
{/*@bgen(jjtree)*/
  protected JJTInterpreterState jjtree = new JJTInterpreterState();

/*@egen*/
	// These are static so that they are reachable by code that doesn't
	// necessarily have an interpreter reference (e.g. tracing in utils).
    static PrintStream debug = System.err;
    public static boolean DEBUG = Boolean.getBoolean("debug");

    NameSpace globalNameSpace;
	This bshObject;
    Reader in;
    PrintStream out;
    PrintStream err;
    ConsoleInterface console; 

	// Can these be combined?
    private boolean 
		evalOnly, 		// Interpreter has no input stream, use eval() only
		interactive;	// Interpreter has a user, print prompts, etc.

	/**
		The main constructor.
		All constructors should now pass through here.

		If namespace is non-null then this interpreter's root 
		will be made a child of the specified namespace. 
	*/
    public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace)
    {
        this( in );
        this.in = in;
        this.out = out;
        this.err = err;
        this.interactive = interactive;
		debug = err;  // correct?

		if ( namespace == null )
        	this.globalNameSpace = new NameSpace("global");
		else
			this.globalNameSpace = namespace;

        try {
            // To speed ambiguos name parsing
            NameSpace.loadJavaPackagesOptimization();

            // The classes which are imported by default
            NameSpace.loadDefaultImports(globalNameSpace);
        } catch(Exception e) {
            error("Couldn't load interpreter resources...");
        }

		/* 
			Create the root "bsh" system object if it doesn't exist.
		*/
		Object bo = globalNameSpace.getVariable("bsh");
		if ( ! (bo instanceof bsh.This) ) {
			initRootSystemObject();

			// set the bsh variable in our root namespace
			try {
				globalNameSpace.setVariable( "bsh", bshObject );
			} catch ( EvalError e ) {
				throw new InterpreterError("can't create system namespace");
			}
		} else
			bshObject = (bsh.This)bo;

		if ( interactive )
			loadRCFiles();
    }

	private void initRootSystemObject() 
	{
		bshObject = new NameSpace( "Bsh System Object" ).getThis( this );

		// bsh.help
		This helpText = new NameSpace( 
			bshObject.namespace, "Bsh Command Help Text" ).getThis( this );
		setBshVariable( "help", helpText );

		// bsh.cwd
		try {
			setBshVariable( "cwd", System.getProperty("user.dir") );
		} catch ( SecurityException e ) { 
			// applets can't see sys props
			setBshVariable( "cwd", "." );
		}

		// bsh.interactive
		setBshVariable( "interactive", new Primitive(interactive) );
		// bsh.evalOnly
		setBshVariable( "evalOnly", new Primitive(evalOnly) );
	}

    public Interpreter(
		Reader in, PrintStream out, PrintStream err, boolean interactive)
    {
        this(in, out, err, interactive, null);
    }

	/**
		Construct a new interactive interpreter attached to the specified 
		console using the specified parent namespace.
	*/
    public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {

        this( new InputStreamReader(console.getIn()), 
			console.getOut(), console.getErr(), 
			true, globalNameSpace );

		setConsole( console );

		/*
        // redirect system out/err to console if possible
		We no longer do this.  Instead we have an option in Console menu
		to capture stdin/stdout

        try {
            System.setOut(console.getOutStream());
            System.setErr(console.getErrStream());
        } catch (Exception e) { }
		*/
    }

	/**
		Construct a new interactive interpreter attached to the specified 
		console.
	*/
    public Interpreter(ConsoleInterface console) {
        this(console, null);
    }

	/**
		Create an interpreter for evaluation only.
	*/
    public Interpreter()
    {
		this( new StringReader(""), 
			System.out, System.err, false, null );
        evalOnly = true;
		setBshVariable( "evalOnly", new Primitive(true) );
    }

	/**
		Create an interpreter and source the specified resource file.
		Note:
		Resource files of course are located relative to the classpath 
		and may be stored in separate files or inside of JAR files.
		'resource' is relative to the bsh package unless you specify an
		absolute "/xxx" path.
		
		@throws EvalError since it does a source.
    public Interpreter( String resource )
		throws EvalError
    {
		this();
		InputStream in = getClass().getResourceAsStream( resource );
		if ( in == null )
			throw new EvalError("Script not found: "+resource);
		in = new BufferedInputStream( in );
		eval( new InputStreamReader(in), globalNameSpace, resource );
    }
	*/

	// dumb helper method
	void setBshVariable( String name, Object obj ) {
		try {
			bshObject.namespace.setVariable( name, obj );
		} catch (EvalError e ) {
			throw new InterpreterError("Internal error: bsh namespace");
		}
	}

	// dumb helper method
	Object getBshVar( String name ) {
		return unwrap( bshObject.namespace.getVariable( name ) );
	}

	public void setConsole( ConsoleInterface console ) {
		this.console = console;
		setBshVariable( "console", console );
	}

	// End constructors

    public static void main( String [] args ) {

        if ( args.length > 0 ) {
			String filename = args[0];

			String [] bshArgs;
			if ( args.length > 1 ) {
				bshArgs = new String [ args.length -1 ];
				System.arraycopy( args, 1, bshArgs, 0, args.length-1 );
			} else
				bshArgs = new String [0];

            Interpreter interpreter = new Interpreter();
			interpreter.setBshVariable( "args", bshArgs );
			try {
				interpreter.source( filename, interpreter.globalNameSpace );
			} catch ( FileNotFoundException e ) {
				System.out.println("File not found: "+e);
			} catch ( EvalError e ) {
				System.out.println("Error in file: "+e);
			}
        } else {
			// Workaround for JDK bug 4071281, where system.in.available() 
			// returns too large a value. This bug has been fixed in JDK 1.2.
			InputStream src;
			if ( System.getProperty("os.name").startsWith("Windows") 
				&& System.getProperty("java.version").startsWith("1.1."))
			{
				src = new FilterInputStream(System.in) {
					public int available() throws IOException {
						return 0;
					}
				};
			}
			else
				src = System.in;

            Reader in = new CommandLineReader( new InputStreamReader(src));
            Interpreter interpreter = 
				new Interpreter( in, System.out, System.err, true );
        	interpreter.run();
        }
    }

	/*
		Run interactively.  (printing prompts, etc.)
	*/
    public void run() {
        if(evalOnly)
            throw new RuntimeException("bsh Interpreter: No stream");

        /*
          We'll print our banner using eval(String) in order to
          exercise the parser and get the basic expression classes loaded...
          This ameliorates the delay after typing the first statement.
        */
        if ( interactive )
			try { 
				eval("printBanner();"); 
			} catch ( EvalError e ) {
				println("BeanShell 1.01 beta - by Pat Niemeyer (pat@pat.net)");
			}

        boolean eof = false;
        while(!eof)
        {
            try
            {
                // try to sync up the console
                System.out.flush();
                System.err.flush();
                Thread.yield();  // this helps a little
                if(interactive)
                    print("bsh % ");

                eof = Line();

                if(jjtree.nodeArity() > 0)  // number of child nodes 
                {
                    SimpleNode node = (SimpleNode)(jjtree.rootNode());

                    if(DEBUG)
                        node.dump(">");

                    Object ret = node.eval( globalNameSpace, this );
                    if(ret instanceof ReturnControl)
                        ret = ((ReturnControl)ret).value;
                    if(ret != Primitive.VOID)
                    {
                        setVariable("$_", ret);
                        Object show = getBshVar("show");
                        if(show instanceof Boolean &&
                            ((Boolean)show).booleanValue() == true)
                            println("<" + ret + ">");
                    }
                }
            }
            catch(ParseException e)
            {
                error("Parser Error: " + e.getMessage(DEBUG));
                if(DEBUG)
                    e.printStackTrace();
                if(!interactive)
                    eof = true;

                ReInit(in);
            }
            catch(InterpreterError e)
            {
                error("Internal Error: " + e.getMessage());
                e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(TargetError e)
            {
                error("// Uncaught Exception: " + e.getTarget());
                if(!interactive)
                    eof = true;
            }
            catch (EvalError e)
            {
				String err = 
					( !interactive ? e.getLocation() : "" )+ e.toString();
                error( err );
                if(DEBUG)
                    e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(Exception e)
            {
                error("Unknown error: " + e);
                e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(TokenMgrError e)
            {
				/*
				if ( tokenMgrErrors++ > 25 ) {
					error("Too many token mgr errors, stopping.");
					eof=true;
					return;
				}
				*/
                error("Error parsing input: " + e);
                //e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            finally
            {
                jjtree.reset();
            }
        }
    }

	/**
		Read text from fileName and eval it.
	*/
    public Object source( String filename, NameSpace nameSpace ) 
		throws FileNotFoundException, EvalError 
	{
		File file = pathToFile( filename );
		debug("Sourcing file: "+file);
		Reader in = new BufferedReader( new FileReader(file) );
		return eval( in, nameSpace, filename );
	}

	/**
		Read text from fileName and eval it.
		Convenience method.  Use the global namespace.
	*/
    public Object source( String filename ) 
		throws FileNotFoundException, EvalError 
	{
		return source( filename, globalNameSpace );
	}

    /**
        Spawn a local interpreter to evaluate text in the specified 
		namespace.  

		Return value is the evaluated object (or corresponding primitive 
		wrapper).

		@throws EvalError on script problems
		@throws TargetError on unhandled exceptions from the script
    */
    public Object eval( 
		Reader in, NameSpace nameSpace, String sourceFile ) 
		throws EvalError {

		Object retVal = null;
		debug("eval: nameSpace = "+nameSpace);

		/* 
			Create non-interactive local interpreter for this namespace
			with source from the input stream and out/err same as 
			this interpreter.
		*/
        Interpreter localInterpreter = 
			new Interpreter( in, out, err, false, nameSpace );

        boolean eof = false;
        while(!eof)
        {
            try
            {
                eof = localInterpreter.Line();
                if(localInterpreter.jjtree.nodeArity() > 0)
                {
                    SimpleNode node = 
						(SimpleNode)localInterpreter.jjtree.rootNode();
                    retVal = node.eval( nameSpace, this );
                    if(retVal instanceof ReturnControl)
                        retVal = ((ReturnControl)retVal).value;
                }
            } catch(ParseException e) {
                throw new EvalError(
					"Sourced file: "+sourceFile+" parser Error: " 
					+ e.getMessage( DEBUG ) );
            } catch(InterpreterError e) {
                e.printStackTrace();
                throw new EvalError(
					"Sourced file: "+sourceFile+" internal Error: " 
					+ e.getMessage());
            } catch( TargetError e ) {
                if(DEBUG)
                    e.printStackTrace();
				e.reThrow("Sourced file: "+sourceFile);
            } catch(EvalError e) {
                if(DEBUG)
                    e.printStackTrace();
                throw new EvalError( e.getLocation() + 
					"sourced file: "+sourceFile+"\n"+ e.toString() );
            } catch(Exception e) {
                e.printStackTrace();
                throw new EvalError(
					"Sourced file: "+sourceFile+" unknown error: " 
					+ e.getMessage());
            } catch(TokenMgrError e) {
                throw new EvalError(
					"Sourced file: "+sourceFile+" Token Parsing Error: " 
					+ e.getMessage() );
            } finally {
                localInterpreter.jjtree.reset();
            }
        }
		return unwrap( retVal );
    }

	/**
		Evaluate the inputstream in this interpreter's global namespace.
	*/
    public Object eval( Reader in ) throws EvalError 
	{
		return eval( in, globalNameSpace, "eval stream" );
	}

	/**
		Evaluate the string in this interpreter's global namespace.
	*/
    public Object eval( String statement ) throws EvalError {
		return eval(statement, globalNameSpace);
	}

	/**
		Note: StringBufferInputStream is deprecated, fix this
	*/
    public Object eval( String statement, NameSpace nameSpace ) 
		throws EvalError {

		String s = ( statement.endsWith(";") ? statement : statement+";" );
        return eval( 
			new StringReader(s), nameSpace, "<inline eval>" );
    }

	/* Daniel Leuck: added color */
    public final void error(String s) {

		if ( console != null )
				console.print("// Error: " + s +"\n", Color.red);
		else {
			err.println("// Error: " + s);
			err.flush();
		}
    }

    public final void println(String s)
    {
        print(s + "\n");
    }

    public final void print(String s)
    {
		if(console != null) {
            console.print(s);
        } else {
            out.print(s);
            out.flush();
        }
    }

    public final static void debug(String s)
    {
        if(DEBUG)
            debug.println("// Debug: " + s);
    }

    public Object getVariable(String name)
    {
        Object obj = globalNameSpace.getVariable(name);
		return unwrap( obj );
    }

	/*
		unwrap primitive and map voids to nulls
	*/
	Object unwrap( Object obj ) {
		if ( obj == null )
			return null;

        // map voids to nulls for the outside world
        if(obj == Primitive.VOID)
            return null;

        // unwrap primitives
        if(obj instanceof Primitive)
            return((Primitive)obj).getValue();
        else
            return obj;
	}

	// These are squeltching error... should they?

    public void setVariable(String name, Object value)
    {
        try { globalNameSpace.setVariable(name, value); }
        catch(EvalError e) { error(e.toString()); }
    }

    public void setVariable(String name, int value)
    {
        try { globalNameSpace.setVariable(name, new Primitive(value)); }
        catch(EvalError e) { error(e.toString()); }
    }

    public void setVariable(String name, float value)
    {
        try { globalNameSpace.setVariable(name, new Primitive(value)); }
        catch(EvalError e) { error(e.toString()); }
    }

    public void setVariable(String name, boolean value)
    {
        try { globalNameSpace.setVariable(name, new Primitive(value)); }
        catch(EvalError e) { error(e.toString()); }
    }

	void jjtreeOpenNodeScope(Node n) {
		((SimpleNode)n).firstToken = getToken(1);
	}

	void jjtreeCloseNodeScope(Node n) {
		((SimpleNode)n).lastToken = getToken(0);
	}

	void loadRCFiles() {
		try {
			String rcfile = 
				// Default is c:\windows under win98, $HOME under Unix
				System.getProperty("user.home") + File.separator + ".bshrc";
			source( rcfile, globalNameSpace );
		} catch ( Exception e ) { 
			// squeltch security exception, filenotfoundexception
			debug("Could not find rc file: "+e);
		}
	}

    public File pathToFile( String fileName ) {

		bsh.File file = new bsh.File( fileName );

		String sourceDir, sourceFile;
		String cwd = (String)getBshVar("cwd");

		if ( file.isAbsolute() ) {
			sourceDir = file.dirName();
			sourceFile = file.baseName();
		} else {
			sourceDir = cwd + File.separator + file.dirName();
			sourceFile = file.baseName();
			file = new bsh.File( sourceDir + File.separator + sourceFile );
		} 

		return file;
	}
}

PARSER_END(Interpreter)

SKIP : /* WHITE SPACE */
{ 
	" " | "\t" | "\r" | "\f"
	| "\n" 
	| < NONPRINTABLE: (["\u0000"-" ", "\u0080"-"\u00ff"])+ >
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <HASH_BANG_COMMENT: "#!" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
< BOOLEAN: "boolean" >
| < BREAK: "break" >
| < CLASS: "class" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NEW: "new" >
| < NULL: "null" >
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SWITCH: "switch" >
| < THROW: "throw" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < WHILE: "while" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < GTX: "@gt" >
| < LT: "<" >
| < LTX: "@lt" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < LEX: "@lteq" >
| < GE: ">=" >
| < GEX: "@gteq" >
| < NE: "!=" >
| < BOOL_OR: "||" >
| < BOOL_ORX: "@or" >
| < BOOL_AND: "&&" >
| < BOOL_ANDX: "@and" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_ANDX: "@bitwise_and" >
| < BIT_OR: "|" >
| < BIT_ORX: "@bitwise_or" >
| < XOR: "^" >
| < MOD: "%" >
| < LSHIFT: "<<" >
| < LSHIFTX: "@left_shift" >
| < RSIGNEDSHIFT: ">>" >
| < RSIGNEDSHIFTX: "@right_shift" >
| < RUNSIGNEDSHIFT: ">>>" >
| < RUNSIGNEDSHIFTX: "@right_unsigned_shift" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ANDASSIGNX: "@and_assign" >
| < ORASSIGN: "|=" >
| < ORASSIGNX: "@or_assign" >
| < XORASSIGN: "^=" >
| < MODASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < LSHIFTASSIGNX: "@left_shift_assign" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RSIGNEDSHIFTASSIGNX: "@right_shift_assign" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < RUNSIGNEDSHIFTASSIGNX: "@right_unsigned_shift_assign" >
}


boolean Line() :
{}
{
  (
   LOOKAHEAD( 3 )
   /* 
      The order here is important: Expression must be first.
      else it will match on a minimal expression in...
   */
   Expression() ";"
|  BlockStatement()
|  ImportDeclaration()
  )  { 
		return false; 
	}
  | <EOF> { 
	debug("End of File!"); return true; 
	}
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

void MethodDeclaration()                    :
{/*@bgen(jjtree) MethodDeclaration */
  BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) MethodDeclaration */
    try {
/*@egen*/
    LOOKAHEAD( MethodDeclarationTypeLookahead() )
    ReturnType() t = <IDENTIFIER> { jjtn000.name = t.image; }
    FormalParameters() Block()
|
    t = <IDENTIFIER> { jjtn000.name = t.image; }
    FormalParameters() Block()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void MethodDeclarationLookahead() : { }
{
    LOOKAHEAD( MethodDeclarationTypeLookahead() )
    ReturnType() <IDENTIFIER> FormalParameters() "{"
|
    <IDENTIFIER> FormalParameters() "{"
}

void MethodDeclarationTypeLookahead() : { }
{
    ReturnType() <IDENTIFIER> "("
}

void ImportDeclaration()                    :
{/*@bgen(jjtree) ImportDeclaration */
    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token t = null;
}
{/*@bgen(jjtree) ImportDeclaration */
  try {
/*@egen*/
  "import" AmbiguousName() [ t = "." "*" ] ";"/*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                                 jjtreeCloseNodeScope(jjtn000);
                                               }
/*@egen*/ {
    if ( t != null )
        jjtn000.importPackage = true;
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void VariableDeclarator()                     :
{/*@bgen(jjtree) VariableDeclarator */
  BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) VariableDeclarator */
  try {
/*@egen*/
  t=<IDENTIFIER> [ "=" VariableInitializer() ]/*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                                 jjtreeCloseNodeScope(jjtn000);
                                               }
/*@egen*/ { jjtn000.name = t.image; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/*
Can get rid of this if we ignore postfix array dimensions in declarations.
I don't like them and I don't want to deal with them right now.

void VariableDeclaratorId() #VariableDeclaratorId :
{ Token t; }
{
  t=<IDENTIFIER> { jjtThis.name = t.image; }
  ( "[" "]" { jjtThis.addArrayDimension(); } )*
}
*/

void VariableInitializer() :
{}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer()                   :
{/*@bgen(jjtree) ArrayInitializer */
  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArrayInitializer */
  try {
/*@egen*/
  "{" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void FormalParameters()                   :
{/*@bgen(jjtree) FormalParameters */
  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FormalParameters */
  try {
/*@egen*/
  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/*
void FormalParameter() #FormalParameter :
{ Token t; }
{
    // added [] to Type for bsh.  Removed [ final ] - is that legal?
  [ LOOKAHEAD(2) Type() ] t=<IDENTIFIER> { jjtThis.name = t.image; }
}
*/
void FormalParameter()                  :
{/*@bgen(jjtree) FormalParameter */
  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FormalParameter */
  try {
/*@egen*/
  // added [] to Type for bsh.  Removed [ final ] - is that legal?
  LOOKAHEAD(2) Type() t=<IDENTIFIER>/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                       jjtreeCloseNodeScope(jjtn000);
                                     }
/*@egen*/ { jjtn000.name = t.image; }
|
  t=<IDENTIFIER>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtreeCloseNodeScope(jjtn000);
                 }
/*@egen*/ { jjtn000.name = t.image; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/*
 * Type, name and expression syntax follows.
 */

void Type()       :
{/*@bgen(jjtree) Type */
  BSHType jjtn000 = new BSHType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Type */
  try {
/*@egen*/
  ( PrimitiveType() | AmbiguousName() ) ( "[" "]" { jjtn000.addArrayDimension(); } )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ReturnType()             :
{/*@bgen(jjtree) ReturnType */
  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ReturnType */
  try {
/*@egen*/
  "void"/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
         }
/*@egen*/ { jjtn000.isVoid = true; }
|
  Type()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void PrimitiveType()                :
{/*@bgen(jjtree) PrimitiveType */
  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) PrimitiveType */
try {
/*@egen*/
"boolean"/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
          }
/*@egen*/ { jjtn000.type = Boolean.TYPE; }
| "char"/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
         }
/*@egen*/ { jjtn000.type =  Character.TYPE; }
| "byte"/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
         }
/*@egen*/ { jjtn000.type =  Byte.TYPE; }
| "short"/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
          }
/*@egen*/ { jjtn000.type =  Short.TYPE; }
| "int"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/ { jjtn000.type =  Integer.TYPE; }
| "long"/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
         }
/*@egen*/ { jjtn000.type =  Long.TYPE; }
| "float"/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
          }
/*@egen*/ { jjtn000.type =  Float.TYPE; }
| "double"/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
           }
/*@egen*/ { jjtn000.type =  Double.TYPE; }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
    jjtreeCloseNodeScope(jjtn000);
  }
}
/*@egen*/
}

void AmbiguousName()                :
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{/*@bgen(jjtree) AmbiguousName */
    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token t;
    StringBuffer s;
}
{/*@bgen(jjtree) AmbiguousName */
  try {
/*@egen*/
  t = <IDENTIFIER> {
        s = new StringBuffer(t.image);
    }
  ( LOOKAHEAD(2) "." t = <IDENTIFIER> {
        s.append("."+t.image);
    }
  )*/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
       jjtreeCloseNodeScope(jjtn000);
     }
/*@egen*/ {
        //jjtThis.name = new Name( nameSpace, s.toString() );
        jjtn000.text = s.toString();
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/*
 * Expression syntax follows.
 */

void Expression() :
{ }
{
  LOOKAHEAD( PrimaryExpression() AssignmentOperator() )
  Assignment()
|
  ConditionalExpression()
}

void Assignment()             :
{/*@bgen(jjtree) Assignment */
  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ int op ; }
{/*@bgen(jjtree) Assignment */
  try {
/*@egen*/
  LHSPrimaryExpression()
  op = AssignmentOperator() {
    jjtn000.operator = op;
  }
  Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

int AssignmentOperator() :
{ Token t; }
{
    ( "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "&=" | "^=" | "|=" |
      "<<=" | "@left_shift_assign" | ">>=" | "@right_shift_assign" |
      ">>>=" | "@right_unsigned_shift_assign" )
    {
        t = getToken(0);
        return t.kind;
    }
}

void ConditionalExpression() : 
{ }
{
  ConditionalOrExpression() [ "?" Expression() ":"/*@bgen(jjtree) #TernaryExpression( 3) */
                                                   {
                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
                                                   }
                                                   try {
/*@egen*/ ConditionalExpression()/*@bgen(jjtree)*/
                                                   } catch (Throwable jjte001) {
                                                     if (jjtc001) {
                                                       jjtree.clearNodeScope(jjtn001);
                                                       jjtc001 = false;
                                                     } else {
                                                       jjtree.popNode();
                                                     }
                                                     if (jjte001 instanceof RuntimeException) {
                                                       throw (RuntimeException)jjte001;
                                                     }
                                                     if (jjte001 instanceof ParseException) {
                                                       throw (ParseException)jjte001;
                                                     }
                                                     throw (Error)jjte001;
                                                   } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  3);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
                                                   }
/*@egen*/ ]
}

void ConditionalOrExpression() :
{ Token t=null; }
{
  ConditionalAndExpression()
  ( ( t = "||" | t = "@or" )
    ConditionalAndExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
    {
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/ )*
}

void ConditionalAndExpression() :
{ Token t=null; }
{
  InclusiveOrExpression()
  ( ( t = "&&" | t = "@and" )
    InclusiveOrExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
    {
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/ )*
}

void InclusiveOrExpression() :
{ Token t=null; }
{
  ExclusiveOrExpression()
  ( ( t = "|" | t = "@bitwise_or" )
    ExclusiveOrExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
    {
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/ )*
}

void ExclusiveOrExpression() :
{ Token t=null; }
{
  AndExpression() ( t="^" AndExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
    {
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/ )*
}

void AndExpression() :
{ Token t=null; }
{
  EqualityExpression()
  ( ( t = "&" | t = "@bitwise_and" )
    EqualityExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
    {
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/ )*
}

void EqualityExpression() :
{ Token t = null; }
{
  InstanceOfExpression() ( ( t= "==" | t= "!=" ) InstanceOfExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
    {
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/
  )*
}

void InstanceOfExpression() :
{ Token t = null; }
{
  RelationalExpression()
  [ t = "instanceof" Type()/*@bgen(jjtree) #BinaryExpression( 2) */
                            {
                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                              jjtreeOpenNodeScope(jjtn001);
                            }
                            try {
/*@egen*//*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn001,  2);
                              jjtc001 = false;
                              jjtreeCloseNodeScope(jjtn001);
                            }
/*@egen*/ { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                                jjtreeCloseNodeScope(jjtn001);
                              }
                            }
/*@egen*/ ]
}

void RelationalExpression() :
{ Token t = null; }
{
  ShiftExpression()
  ( ( t = "<" | t = "@lt" | t = ">" | t = "@gt" |
      t = "<=" | t = "@lteq" | t = ">=" | t = "@gteq" )
  ShiftExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
  {
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
  }
/*@egen*/
  { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
  }
/*@egen*/ )*
}

void ShiftExpression() :
{ Token t = null; }
{
  AdditiveExpression()
  ( ( t = "<<" | t = "@left_shift" | t = ">>" | t = "@right_shift" |
      t = ">>>" | t = "@right_unsigned_shift" )
  AdditiveExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
  {
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
  }
/*@egen*/
  { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
  }
/*@egen*/ )*
}

void AdditiveExpression() :
{ Token t = null; }
{
  MultiplicativeExpression()
  ( ( t= "+" | t= "-" ) MultiplicativeExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
                                                   {
                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
                                                   }
                                                   try {
/*@egen*//*@bgen(jjtree)*/
                                                   {
                                                     jjtree.closeNodeScope(jjtn001,  2);
                                                     jjtc001 = false;
                                                     jjtreeCloseNodeScope(jjtn001);
                                                   }
/*@egen*/ { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
                                                   } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  2);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
                                                   }
/*@egen*/
  )*
}

void MultiplicativeExpression() :
{ Token t = null; }
{
  UnaryExpression() ( ( t= "*" | t= "/" | t= "%" )
  UnaryExpression()/*@bgen(jjtree) #BinaryExpression( 2) */
                    {
                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                      jjtreeOpenNodeScope(jjtn001);
                    }
                    try {
/*@egen*//*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn001,  2);
                      jjtc001 = false;
                      jjtreeCloseNodeScope(jjtn001);
                    }
/*@egen*/ { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                        jjtreeCloseNodeScope(jjtn001);
                      }
                    }
/*@egen*/ )*
}

void UnaryExpression() :
{ Token t = null; }
{
  ( t="+" | t="-" ) UnaryExpression()/*@bgen(jjtree) #UnaryExpression( 1) */
    {
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnaryExpressionNotPlusMinus()
}

void PreIncrementExpression() :
{ Token t = null; }
{
  t="++" LHSPrimaryExpression()/*@bgen(jjtree) #UnaryExpression( 1) */
    {
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/
}

void PreDecrementExpression() :
{ Token t = null; }
{
  t="--" LHSPrimaryExpression()/*@bgen(jjtree) #UnaryExpression( 1) */
    {
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/
}

void UnaryExpressionNotPlusMinus() :
{ Token t = null; }
{
  ( t="~" | t="!" ) UnaryExpression()/*@bgen(jjtree) #UnaryExpression( 1) */
    {
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    { jjtn001.kind = t.kind; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/
|
  LOOKAHEAD( CastLookahead() ) CastExpression()
|
  PostfixExpression()
}

// This production is to determine lookahead only.
void CastLookahead() : { }
{
  LOOKAHEAD(2) "(" PrimitiveType()
|
  LOOKAHEAD( "(" AmbiguousName() "[" ) "(" AmbiguousName() "[" "]"
|
  "(" AmbiguousName() ")" ( "~" | "!" | "(" | <IDENTIFIER> | /* "this" | "super" | */ "new" | Literal() )
}

void PostfixExpression() :
{ Token t = null; }
{
 (
  LOOKAHEAD( LHSPrimaryExpression() ("++"|"--") )
  LHSPrimaryExpression()
|
  PrimaryExpression()
 )
  [ ( t="++" | t="--" )/*@bgen(jjtree) #UnaryExpression( 1) */
                        {
                          BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*//*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001,  1);
                          jjtc001 = false;
                          jjtreeCloseNodeScope(jjtn001);
                        }
/*@egen*/ { 
	jjtn001.kind = t.kind; jjtn001.postfix = true; }/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/ ]
}

void CastExpression()                 :
{/*@bgen(jjtree) CastExpression */
  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) CastExpression */
  try {
/*@egen*/
  LOOKAHEAD( "(" PrimitiveType() ) "(" Type() ")" UnaryExpression()
|
  "(" Type() ")" UnaryExpressionNotPlusMinus()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void PrimaryExpression()                    : {/*@bgen(jjtree) PrimaryExpression */
  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) PrimaryExpression */
 try {
/*@egen*/
 PrimaryPrefix() ( PrimarySuffix() )*/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
   }
 }
/*@egen*/
}

// The MethodInvocation node here simplifies the prefix/suffix parsing a bit
//  by forcing the prefix to an object.
void PrimaryPrefix() : { }
{
  Literal()
|
  "(" Expression() ")"
|
  AllocationExpression()
|/*@bgen(jjtree) #MethodInvocation(> 1) */
  {
    BSHMethodInvocation jjtn001 = new BSHMethodInvocation(JJTMETHODINVOCATION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
  }
  try {
/*@egen*/
  ( AmbiguousName() [ Arguments() ]  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      jjtreeCloseNodeScope(jjtn001);
    }
  }
/*@egen*/
}

void PrimarySuffix()                :
{/*@bgen(jjtree) PrimarySuffix */
    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token t = null;
}
{/*@bgen(jjtree) PrimarySuffix */
  try {
/*@egen*/
  LOOKAHEAD(2)
  "." "class"/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtreeCloseNodeScope(jjtn000);
              }
/*@egen*/ {
        jjtn000.operation = BSHPrimarySuffix.CLASS;
    }
|
  "[" Expression() "]"/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                       }
/*@egen*/ {
        jjtn000.operation = BSHPrimarySuffix.INDEX;
    }
|
    // Field access or method invocation
  "." t = <IDENTIFIER> [ Arguments() ]/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                         jjtreeCloseNodeScope(jjtn000);
                                       }
/*@egen*/ {
        jjtn000.operation = BSHPrimarySuffix.NAME;
        jjtn000.field = t.image;
    }
|
  "{" Expression() "}"/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                       }
/*@egen*/ {
        jjtn000.operation = BSHPrimarySuffix.PROPERTY;
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
/*
    For inner classes
|
  LOOKAHEAD(2)
  "." AllocationExpression()
*/
}

/*
    Note: I have gotten rid of LHSPrimaryPrefix because I believe the
    only meaningful rule is the AmbiguousName.  I believe the only other
    plausable rule was AllocationExpression...  don't see the point right now.
*/
void LHSPrimaryExpression()                       : {/*@bgen(jjtree) LHSPrimaryExpression */
  BSHLHSPrimaryExpression jjtn000 = new BSHLHSPrimaryExpression(JJTLHSPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) LHSPrimaryExpression */
  try {
/*@egen*/
  AmbiguousName()  ( LHSPrimarySuffix( ) )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void LHSPrimarySuffix()                   :
{/*@bgen(jjtree) LHSPrimarySuffix */
    BSHLHSPrimarySuffix jjtn000 = new BSHLHSPrimarySuffix(JJTLHSPRIMARYSUFFIX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token t=null, t1, t2 = null;
}
{/*@bgen(jjtree) LHSPrimarySuffix */
  try {
/*@egen*/
    // Indexed to a field
  "[" Expression() "]"/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                       }
/*@egen*/ {
        jjtn000.operation = BSHLHSPrimarySuffix.INDEX;
    }
|
    // Field access or method invocation followed by field access
  "." t1 = <IDENTIFIER> [ Arguments() "." t2 = <IDENTIFIER> ]/*@bgen(jjtree)*/
                                                              {
                                                                jjtree.closeNodeScope(jjtn000, true);
                                                                jjtc000 = false;
                                                                jjtreeCloseNodeScope(jjtn000);
                                                              }
/*@egen*/ {
        jjtn000.operation = BSHLHSPrimarySuffix.NAME;
        if ( t2 == null )
            jjtn000.field = t1.image;
        else {
            jjtn000.method = t1.image;
            jjtn000.field = t2.image;
        }
    }
|
  "{" Expression() "}"/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                       }
/*@egen*/ {
        jjtn000.operation = BSHLHSPrimarySuffix.PROPERTY;
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void Literal()          :
{/*@bgen(jjtree) Literal */
    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token x;
    boolean b;
    String literal;
    char ch;
}
{/*@bgen(jjtree) Literal */
  try {
/*@egen*/
  x = <INTEGER_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  {
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'l' || ch == 'L')
    {
        literal = literal.substring(0,literal.length()-1);

        // This really should be Long.decode, but there isn't one. As a result,
        // hex and octal literals ending in 'l' or 'L' don't work.
        jjtn000.value = new Primitive( new Long( literal ) );
    }
    else
        jjtn000.value = new Primitive( Integer.decode( literal ) );
  }
|
  x = <FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  {
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'f' || ch == 'F')
    {
        literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Float( literal ) );
    }
    else
    {
        if(ch == 'd' || ch == 'D')
            literal = literal.substring(0,literal.length()-1);

        jjtn000.value = new Primitive( new Double( literal ) );
    }
  }
|
  x = <CHARACTER_LITERAL>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtreeCloseNodeScope(jjtn000);
                          }
/*@egen*/ {
    jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );
    }
|
  x = <STRING_LITERAL>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                       }
/*@egen*/ {
    jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );
    }
|
  b = BooleanLiteral()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
                        }
/*@egen*/  {
    jjtn000.value = new Primitive( new Boolean(b) ); }
|
  NullLiteral()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                }
/*@egen*/ {
    jjtn000.value = Primitive.NULL; }
|
 VoidLiteral()/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtreeCloseNodeScope(jjtn000);
               }
/*@egen*/ {
    jjtn000.value = Primitive.VOID; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

boolean BooleanLiteral() :
{}
{
  "true" { return true; }
|
  "false" { return false; }
}

void NullLiteral() :
{}
{
  "null"
}

void VoidLiteral() :
{}
{
  "void"
}

void Arguments()            :
{/*@bgen(jjtree) Arguments */
  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Arguments */
  try {
/*@egen*/
  "(" [ ArgumentList()  ]  ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

// leave these on the stack for Arguments() to handle
void ArgumentList() :
{ }
{
  Expression()
  ( "," Expression() )*
}

void AllocationExpression()                       :
{/*@bgen(jjtree) AllocationExpression */
  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) AllocationExpression */
  try {
/*@egen*/
  LOOKAHEAD(2)
  "new" PrimitiveType() ArrayDimensions()
|
  "new" AmbiguousName() ( ArrayDimensions() | Arguments() )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ArrayDimensions()                  :
{/*@bgen(jjtree) ArrayDimensions */
  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArrayDimensions */
  try {
/*@egen*/
  LOOKAHEAD(2)
  ( LOOKAHEAD(2) "[" Expression() "]" { jjtn000.addArrayDimension(); } )+
  // Removed trailing "[]" identifiers.  Specify array dims fully.
|
  ( "[" "]" { jjtn000.addArrayDimension(); } )+ ArrayInitializer()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}


/*
 * Statement syntax follows.
 */

void Statement() : { }
{
  LOOKAHEAD(2)
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
|
  StatementExpression() ";"
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
|
  TryStatement()
}

void LabeledStatement() :
{}
{
  <IDENTIFIER> ":" Statement()
}

void Block()        :
{/*@bgen(jjtree) Block */
  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
  try {
/*@egen*/
  "{" ( BlockStatement() )* "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void BlockStatement() :
{}
{
  LOOKAHEAD( MethodDeclarationLookahead() ) MethodDeclaration()
|
  LOOKAHEAD([ "final" ] Type() <IDENTIFIER>)
  TypedVariableDeclaration() ";"
|
  Statement()
}

void EmptyStatement() :
{}
{
  ";"
}

void StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.
 */
{ }
{
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  LOOKAHEAD( PrimaryExpression() AssignmentOperator() )
  Assignment() { }
|
  PostfixExpression()
}

void SwitchStatement() :
{}
{
  "switch" "(" Expression() ")" "{"
    ( SwitchLabel() ( BlockStatement() )* )*
  "}"
}

void SwitchLabel() :
{}
{
  "case" Expression() ":"
|
  "default" ":"
}

void IfStatement()              :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{/*@bgen(jjtree) IfStatement */
  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
  try {
/*@egen*/
  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void WhileStatement()                 :
{/*@bgen(jjtree) WhileStatement */
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
  try {
/*@egen*/
  "while" "(" Expression() ")" Statement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/*
	Do statement is just a While statement with a special hook to execute
	at least once.
*/
void DoStatement()                 :
{/*@bgen(jjtree) WhileStatement */
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
  try {
/*@egen*/
  "do" Statement() "while" "(" Expression() ")" ";"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/ 
	{ jjtn000.isDoStatement=true;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ForStatement()               :
{/*@bgen(jjtree) ForStatement */
  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForStatement */
  try {
/*@egen*/
  "for" "(" [ ForInit() { jjtn000.hasForInit=true; } ]
    ";" [ Expression() { jjtn000.hasExpression=true; } ]
    ";" [ ForUpdate() { jjtn000.hasForUpdate=true; } ] ")"
    Statement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ForInit() :
{ Token t = null; }
{
  LOOKAHEAD( [ t="final" ] Type() <IDENTIFIER> )
  TypedVariableDeclaration()
|
  StatementExpressionList()
}

void TypedVariableDeclaration()                           :
{/*@bgen(jjtree) TypedVariableDeclaration */
  BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) TypedVariableDeclaration */
  try {
/*@egen*/
  [ t="final" ] Type() VariableDeclarator() ( "," VariableDeclarator() )*/*@bgen(jjtree)*/
                                                                           {
                                                                             jjtree.closeNodeScope(jjtn000, true);
                                                                             jjtc000 = false;
                                                                             jjtreeCloseNodeScope(jjtn000);
                                                                           }
/*@egen*/  {
        jjtn000.isFinal = (t!=null);
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void StatementExpressionList()                          :
{/*@bgen(jjtree) StatementExpressionList */
  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementExpressionList */
  try {
/*@egen*/
  StatementExpression() ( "," StatementExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ForUpdate() :
{}
{
  StatementExpressionList()
}

void BreakStatement()                  :
{/*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatement */
  try {
/*@egen*/
  "break" [ <IDENTIFIER> ] ";"/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                                 jjtreeCloseNodeScope(jjtn000);
                               }
/*@egen*/ { jjtn000.kind = BREAK; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ContinueStatement()                  :
{/*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatement */
  try {
/*@egen*/
  "continue" [ <IDENTIFIER> ] ";"/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                    jjtreeCloseNodeScope(jjtn000);
                                  }
/*@egen*/ { jjtn000.kind = CONTINUE; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ReturnStatement()                  :
{/*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatement */
  try {
/*@egen*/
  "return" [ Expression() ] ";"/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  jjtreeCloseNodeScope(jjtn000);
                                }
/*@egen*/ { jjtn000.kind = RETURN; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ThrowStatement()                 :
{/*@bgen(jjtree) ThrowStatement */
  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ThrowStatement */
  try {
/*@egen*/
  "throw" Expression() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void TryStatement()              :
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{/*@bgen(jjtree) TryStatement */
  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TryStatement */
  try {
/*@egen*/
  "try" Block()
  ( "catch" "(" FormalParameter() ")" Block() )*
  [ "finally" Block() ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

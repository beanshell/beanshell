// For the moment, you can just generate the
// sources in ../java/bsh/congo/* by
// running:
//  java -jar javacc-full.jar Beanshell.ccc
// on the command line.
//

JAVA_UNICODE_ESCAPE=true;
DEFAULT_LEXICAL_STATE=JAVA;
BASE_NAME="Beanshell";
PARSER_PACKAGE=bsh.congo.parser;
NODE_PACKAGE=bsh.congo.tree;
ENSURE_FINAL_EOL=true;
BASE_SRC_DIR="../java";
LEGACY_GLITCHY_LOOKAHEAD=false;
//TOKENS_ARE_NODES=false;

INCLUDE JAVA

INJECT Node :
import bsh.CallStack;
import bsh.Interpreter;
import bsh.InterpreterError;
import bsh.EvalError;
import java.io.Serializable;
extends Serializable
{
    /** This is the general signature for evaluation of a node.
     * @param callstack evaluation call stack
     * @param interpreter evaluation interpreter
     * @return result from evaluation
     * @throws EvalError if an evaluation error occurred */
    default Object eval(CallStack callstack, Interpreter interpreter) throws EvalError {
      throw new InterpreterError(
            "Unimplemented or inappropriate for " + getClass().getName() );
    }

    default String getSourceFile() {return getInputSource();}

    default void setSourceFile(String sourceFile) { /* default implementation does nothing */ }

    default String toString(String prefix) {throw new UnsupportedOperationException();}

    default boolean isLegacyNode() {return getClass().getSimpleName().startsWith("BSH");}

    default int getLineNumber() {return getBeginLine();}

    default void setLineNumber(int lineNumber) { /* default implementation does nothing */}

    default String getText() {return getSource();}

    default void setText(String text) { /* default implementation does nothing */}

    default Class<?> getTypeInfo() {return this.getClass();};
}

INJECT BaseNode :
import bsh.BSHLabeledStatement;
{
    private static final long serialVersionUID = 1L;

    private String text, sourceFile;
    private int lineNumber = -1;

    public String getText() {
       return text == null ? getSource() : text;
    }

    public void setText(String text) {this.text = text;}

    public int getLineNumber() {
        return lineNumber > 0 ? lineNumber : getBeginLine();
    }

    public void setLineNumber(int lineNumber) {this.lineNumber = lineNumber;}

    public void setSourceFile(String sourceFile) {this.sourceFile = sourceFile;}

    public String getSourceFile() {
        if (sourceFile == null) {
            if (getParent() != null && getParent().getSourceFile() != null) return getParent().getSourceFile();
            return getInputSource();
        }
        return sourceFile;
    }

    protected String getLabel() {
        if (getParent() instanceof BSHLabeledStatement) {
            return ((BSHLabeledStatement) getParent()).getLabel();
        }
        return null;
    }

    public List<Node> childrenNodes() {
        return children.stream().filter(this::isNotToken).toList();
    }

    private boolean isNotToken(Node n) {
        return n != null && !Token.class.isAssignableFrom(n.getClass());
    }

    public void dump(String prefix) {
        if (isNotToken(this)) System.out.println(toString(prefix));
        if (children != null) for (Node n : childrenNodes())
            n.dump(prefix + " ");
    }

    public String toString() {
        String result = BaseNode.class.equals(getClass().getSuperclass())
            ? getClass().getSimpleName()
            : getClass().getSuperclass().getSimpleName();
        //if (result.startsWith("BSH")) result = result.substring(3);
        return result;
    }

    public String toString(String prefix) { return prefix + toString(); }

    public void ndump(String prefix) { Node.super.dump(prefix); }
}

TOKEN :
  < FORMAL_COMMENT:
       "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/"
  >
;


INJECT BasicForStatement : extends bsh.BSHForStatement
INJECT BreakStatement : extends bsh.BSHReturnStatement
INJECT CodeBlock : extends bsh.BSHBlock
INJECT ContinueStatement : extends bsh.BSHReturnStatement
INJECT EnhancedForStatement : extends bsh.BSHEnhancedForStatement
INJECT IfStatement : extends bsh.BSHIfStatement
INJECT LocalVariableDeclaration : extends bsh.BSHTypedVariableDeclaration
INJECT ReturnStatement : extends bsh.BSHReturnStatement
INJECT SwitchStatement : extends bsh.BSHSwitchStatement
INJECT SynchronizedStatement : extends bsh.BSHBlock
INJECT ThrowStatement : extends bsh.BSHThrowStatement
INJECT TryStatement : extends bsh.BSHTryStatement
INJECT ArrayDimsAndInits : implements Expression
INJECT PowerExpression : implements Expression
INJECT ElvisExpression : implements Expression

INJECT LabeledStatement : extends bsh.BSHLabeledStatement
{
    public String getLabel() {
        return firstDescendantOfType(Identifier.class).getImage();
    }
}

INJECT DoStatement : extends bsh.BSHWhileStatement
{
   @Override
   public Node getConditionNode() {
      return firstChildOfType(LPAREN).nextSibling();
   }

   public Node getBody() {
       return firstChildOfType(DO).nextSibling();
   }
}

INJECT WhileStatement : extends bsh.BSHWhileStatement
{
    @Override
    public Node getConditionNode() {
      return firstChildOfType(Expression.class);
    }

    @Override
    public Node getBody() {
        return firstChildOfType(Statement.class);
    }
}

INJECT Expression :
{
  default boolean isPrimary() {return false;}
}

INJECT PrimaryExpression : extends Expression
{
  default boolean isPrimary() {
    return !(getParent() instanceof PrimaryExpression);
  }
}

INJECT AdditiveExpression : extends bsh.BSHBinaryExpression
INJECT MultiplicativeExpression : extends bsh.BSHBinaryExpression
INJECT AndExpression : extends bsh.BSHBinaryExpression
INJECT ExclusiveOrExpression : extends bsh.BSHBinaryExpression
INJECT ArrayInitializer : extends bsh.BSHArrayInitializer
INJECT AssignmentExpression : extends bsh.BSHAssignment
INJECT CastExpression : extends bsh.BSHCastExpression
{
   @Override
   public Node getTypeNode() {return firstChildOfType(Type.class);}

   @Override
   public Node getExpressionNode() {return firstChildOfType(Expression.class);}
}

INJECT ConditionalAndExpression : extends bsh.BSHBinaryExpression
INJECT ConditionalOrExpression : extends bsh.BSHBinaryExpression
INJECT EqualityExpression : extends bsh.BSHBinaryExpression
INJECT ExclusiveExpression : extends bsh.BSHBinaryExpression
INJECT FormalComment: extends bsh.BSHFormalComment
INJECT FormalParameters: extends bsh.BSHFormalParameters
INJECT InclusiveExpression : extends bsh.BSHBinaryExpression
INJECT InstanceofExpression : extends bsh.BSHBinaryExpression
INJECT InvocationArguments : extends bsh.BSHArguments
INJECT ReferenceType : extends bsh.BSHType
INJECT PrimitiveType : extends bsh.BSHPrimitiveType
INJECT DotThis : extends bsh.BSHPrimaryExpression
INJECT MethodCall : extends bsh.BSHMethodInvocation
INJECT MethodDeclaration : extends bsh.BSHMethodDeclaration
INJECT ExpressionStatement : extends bsh.BSHAssignment
INJECT ObjectType : extends bsh.BSHType
INJECT PostfixExpression : extends bsh.BSHUnaryExpression
INJECT PreDecrementExpression : extends bsh.BSHUnaryExpression
INJECT PreIncrementExpression : extends bsh.BSHUnaryExpression
INJECT RelationalExpression : extends bsh.BSHBinaryExpression
INJECT ReturnType : extends bsh.BSHReturnType
INJECT ShiftExpression : extends bsh.BSHBinaryExpression
INJECT TernaryExpression : extends bsh.BSHTernaryExpression
INJECT UnaryExpression : extends bsh.BSHUnaryExpression
INJECT UnaryExpressionNotPlusMinus : extends bsh.BSHUnaryExpression
INJECT AllocationExpression : extends bsh.BSHAllocationExpression
INJECT LiteralExpression : extends bsh.BSHLiteral
{
    @Override
    public Object getValue() {
        return super.getValue() == null && getChildCount() > 0 ? getChild(0) : super.getValue();
    }
}
INJECT Name : extends bsh.BSHAmbiguousName
{
    @Override
    public String getName() {
        return children().stream().map(n->n==null?"":n.toString()).reduce("",(a,b)->a+b);
    }
}
INJECT DotName : extends bsh.BSHAmbiguousName
{
    @Override
    public String getName() {
        return children().stream().map(n->n==null?"":n.toString()).reduce("",(a,b)->a+b);
    }
}

INJECT ArrayAccess : extends bsh.BSHPrimaryExpression // This is maybe not quite right

INJECT ClassDeclaration : extends bsh.BSHClassDeclaration
INJECT InterfaceDeclaration : extends bsh.BSHClassDeclaration
INJECT EnumDeclaration : extends bsh.BSHClassDeclaration

UNPARSED : /* COMMENTS */
 <HASH_BANG_COMMENT: "#!" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
// | <MULTI_LINE_COMMENT:
//    ("/***" (["*"])* | "/*") (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
;

// A redefinition of some operators from the Java grammar
// to admit an alternative form. Also, some extra operators, such
// as SPACESHIP and ELVIS that do not exist in Java.
TOKEN #Operator :
  < GT: ">" | "@gt" >
  |
  < LT: "<" | "@lt" >
  |
  < LE: "<=" | "@lteq" >
  |
  < GE: ">=" | "@gteq" >
  |
  < SC_OR : "||" | "@or" >
  |
  < SC_AND : "&&" | "@and" >
  |
  < BIT_AND: "&" | "@bitwise_and" >
  |
  < BIT_OR: "|" | "@bitwise_or" >
  |
  < XOR: "^" | "@bitwise_xor" >
  |
  < REM : "%" | "@mod" >
  |
  < POWER: "**" | "@pow" >
  |
  < LSHIFT: "<<" | "@left_shift" >
  |
  < RSIGNEDSHIFT: ">>" | "@right_shift" >
  |
  < RUNSIGNEDSHIFT: ">>>" | "@right_unsigned_shift" >
  |
  < ANDASSIGN: "&=" | "@and_assign" >
  |
  < ORASSIGN: "|=" | "@or_assign" >
  |
  < XORASSIGN: "^=" | "@xor_assign" >
  |
  < REMASSIGN: "%=" | "@mod_assign" >
  |
  < POWERASSIGN: "**=" | "@pow_assign" >
  |
  < LSHIFTASSIGN: "<<=" | "@left_shift_assign" >
  |
  < RSIGNEDSHIFTASSIGN: ">>=" | "@right_shift_assign" >
  |
  < RUNSIGNEDSHIFTASSIGN: ">>>=" | "@right_unsigned_shift_assign" >
  |
  < SPACESHIP: "<=>" >
  |
  < NULLCOALESCEASSIGN: "??=" >
  |
  < NULLCOALESCE: "??" >
  |
  < ELVIS: "?:" >
  |
  < MOD: "%" | "@mod" >
  |
  < MODASSIGN: "%=" | "@mod_assign" >
;

TOKEN :
  <CHARACTER_LITERAL :
      "'"
      (   (~["'","\\","\n","\r"])
          |
          <STRING_ESCAPE>
      )*
      "'"
  > #StringLiteral
;


boolean Line :
  <EOF> {
//    Interpreter.debug("End of File!");
    return true;
  }
  |
  BlockStatement {
    return false;
  }
;

java.util.List<Node> Statements#void :
  (BlockStatement)*
  {
      return new java.util.ArrayList<>(currentNodeScope);
  }
;

ConditionalExpression :
  NullCoalesceElvisSpaceShipExpression [ <HOOK> Expression <COLON> ConditionalExpression]
;


AllocationExpression :
  ["new"] =>|+1 (ArrayDimsAndInits | ArrayInitializer)
  |
  "new" PrimitiveType =>|| ArrayDimsAndInits
  |
  "new" [TypeArguments] ObjectType [ PossiblyEmptyTypeArguments ]
    (
      ArrayInitializer
      |
      ArrayDimsAndInits
      |
      InvocationArguments [ ClassOrInterfaceBody ]
    )
;

// For now, redefining the following to generate binary expressions.

AdditiveExpression :
   MultiplicativeExpression (((<PLUS>|<MINUS>) MultiplicativeExpression) #AdditiveExpression(+1))*
;

MultiplicativeExpression :
   PowerExpression (((<STAR>|<SLASH>|<REM>) PowerExpression) #MultiplicativeExpression(+1))*
;

PowerExpression :
   UnaryExpression ((<POWER>UnaryExpression)#PowerExpression(+1))*
;

ConditionalOrExpression :
  ConditionalAndExpression ((<SC_OR> ConditionalAndExpression) #ConditionalOrExpression(+1))*
;

ConditionalAndExpression :
  InclusiveOrExpression ((<SC_AND> InclusiveOrExpression) #ConditionalAndExpression(+1))*
;

InclusiveOrExpression :
  ExclusiveOrExpression ((<BIT_OR> ExclusiveOrExpression) #InclusiveOrExpression(+1))*
;

ExclusiveOrExpression :
  AndExpression ((<XOR> AndExpression) #ExclusiveOrExpression(+1))*
;

EqualityExpression :
  InstanceOfExpression (((<EQ>|<NE>|<SPACESHIP>) InstanceOfExpression) #EqualityExpression(+1))*
;

RelationalExpression :
  ShiftExpression (((<LT>|<GT>|<LE>|<GE>) ShiftExpression) #RelationalExpression(+1))*
;

ElvisExpression :
   ShiftExpression (<ELVIS> ShiftExpression)*
;

ShiftExpression :
   AdditiveExpression
   [
     // Under certain conditions we scanned forward
     // and (incorrectly) scanned a >>, so we uncache
     // the tokens and end up rescanning!
     SCAN <GT> (<GT>|<RSIGNEDSHIFT>) => UNCACHE_TOKENS
   ]
   (
      ((<LSHIFT> | <RSIGNEDSHIFT> | <RUNSIGNEDSHIFT>)
      AdditiveExpression) #ShiftExpression(+1)
   )*
;

AndExpression :
  EqualityExpression ((<BIT_AND> EqualityExpression) #AndExpression(+1))*
;

ExclusiveOrExpression :
  AndExpression ((<XOR> AndExpression) #ExclusiveOrExpression(+1))*
;

NullCoalesceElvisSpaceShipExpression :
  ConditionalOrExpression
  (((<NULLCOALESCE>|<ELVIS>|<SPACESHIP>) ConditionalOrExpression) #NullCoalesceElvisSpaceShipExpression(+1) )*
;

INJECT TryWithResources :
    import java.util.List;
    import java.util.ArrayList;
{
    public List<Node> getResources() {
        List<Node> result = new ArrayList<>();
        for (Node n : children()) {
            if (n instanceof LocalVariableDeclaration
                || n instanceof Name
                || n instanceof DotName) {
                  result.add(n);
                }
            if (n.getTokenType() == RPAREN) break;
        }
        return result;
    }
}

AssignmentOperator #void :
  <ASSIGN> | <STARASSIGN> | <SLASHASSIGN> | <REMASSIGN> | <PLUSASSIGN>
  | <MINUSASSIGN> | <LSHIFTASSIGN> | <RSIGNEDSHIFTASSIGN>
  | <RUNSIGNEDSHIFTASSIGN> | <ANDASSIGN> | <XORASSIGN> | <ORASSIGN>
  | <POWERASSIGN> | <NULLCOALESCEASSIGN>
;

BlockStatement#void :
 ASSERT ~((<FINAL>|Annotation)* (<PUBLIC>|<PRIVATE>|<PROTECTED>|<STATIC>)) : "Cannot declare anything to be public, private, protected, or static  in a local context"
 (
  AssertStatement
  |
// The YieldStatement option in the Statement production will thus never
// be matched but this doesn't seem to be a problem really.
// We need YieldStatement up top here so it does not spuriously match LocalVariableDeclaration.
  YieldStatement
  |
  RecordDeclaration
  |
  SCAN MethodDeclarationLA
  =>MethodDeclaration
  |
  LocalVariableDeclaration
  {Node varDecl = peekNode();}
  <SEMICOLON>
  {varDecl.addChild(popNode());}
  |
  ClassDeclaration
  |
  InterfaceDeclaration
  |
  EnumDeclaration
  |
  Statement
  |
 // Allow BeanShell imports in any block
  ImportDeclaration
  |
  // Allow BeanShell package declarations in any block
  PackageDeclaration
  |
  FormalComment
 )
;

MethodDeclarationLA#scan :
  Modifiers
  [ TypeParameters ]
  ReturnType
  <IDENTIFIER>
  FormalParameters ( (Annotation)* <LBRACKET><RBRACKET> )*
  [ ThrowsList ] <LBRACE>
;

FormalComment# : <FORMAL_COMMENT> ;


INJECT Property : implements PrimaryExpression
{
public boolean isAssignable() {return true;}
}

ArrayDimsAndInits# :
SCAN 2
(
  <LBRACKET> =>|+1 Expression <RBRACKET>
)+
(
  (Annotation)* <LBRACKET><RBRACKET> =>||
)*
|
(
  (Annotation)* <LBRACKET><RBRACKET>
)* // It seems this is optional in Beanshell
ArrayInitializer
;

ReturnType# : [<VOID> | SCAN ~(Type <LPAREN>) => Type] ;

//ExpressionStatement : Expression [AssignmentOperator Expression] <SEMICOLON> ;

StatementExpression : Expression;

Literal #void :
<INTEGER_LITERAL>
|
<LONG_LITERAL>
|
<FLOATING_POINT_LITERAL>
|
<CHARACTER_LITERAL>
|
<STRING_LITERAL>
|
<TEXT_BLOCK_LITERAL>
|
<TRUE>
|
<FALSE>
|
<NULL>
|
// Added for Beanshell
<VOID>
;

ImportDeclaration :
  <_IMPORT> [<STATIC>]
  (
    <STAR>
    |
    Name {Node nameNode = peekNode();}
    [
        <DOT> {nameNode.addChild(popNode());}
        <STAR> {nameNode.addChild(popNode());}
    ]
  )
  <SEMICOLON>
;


FormalParameter : 
  {permissibleModifiers = EnumSet.of(FINAL);}# 
  Modifiers 
  [Type ASSERT ([(Annotation)* <VAR_ARGS>] <IDENTIFIER>) =>||]
  [ (Annotation)* <VAR_ARGS> ] 
  VariableDeclaratorId 
;

FieldDeclaration :
{permissibleModifiers = EnumSet.of(PUBLIC, PROTECTED, 
                                    PRIVATE, STATIC, FINAL, 
                                    TRANSIENT, VOLATILE);}#
Modifiers /modifiers/
//[Type ASSERT(<IDENTIFIER>) =>||] 
Type
VariableDeclarator =>|| 
( <COMMA> VariableDeclarator )* <SEMICOLON>
;

CatchBlock :
    <CATCH>
    <LPAREN>
    [<FINAL>]
    (
      <IDENTIFIER> ASSERT (<RPAREN>) =>||
      |
      ObjectType (<BIT_OR> ObjectType )* VariableDeclaratorId
    )
    <RPAREN>
    Block
;

PrimaryExpression#interface :
 (
  LiteralExpression
  |
  <THIS> #LiteralExpression
  |
  <SUPER> #LiteralExpression
  |
  Parentheses
  |
  AllocationExpression
  |
  ClassLiteral
  |
  MethodReference
  |
  Name
 )
 (
  (<DOT> <THIS> =>||) #DotThis(+1)
  |
  (<DOT> <SUPER> =>||) #DotSuper(+1)
  |
  (<DOT> =>|+1 AllocationExpression) #DotNew(+1)
  |
  (
    <LBRACKET>
    DEACTIVATE_TOKENS DOUBLE_COLON
    (
      [ Expression ]
      [
        <COLON>
        [ Expression ]
        [
          <COLON>
          [ Expression ]
        ]
      ]
    )
    <RBRACKET>
  ) #ArrayAccess(+1)
  |
  // This is only in Beanshell
  <LBRACE>Expression<RBRACE> #Property(+1)
  |
  (<DOT> [TypeArguments] <IDENTIFIER>) #DotName(+1)
  |
  (<DOUBLE_COLON> [TypeArguments] (<IDENTIFIER>|<NEW>)) #MethodReference(+1)
  |
// The following commented-out line is the absolutely correct condition for recent JDK's,
// since yield on its own cannot be a method call, though you can write this.yield(), for example.
// For now, I'm not including a check for that. The compiler catches it, after all. Also, it is
// still unclear to me whether this should be caught at this point or if it is better to just do
// a post-parse tree walk that runs over the AST and checks for these things.
//  SCAN 1 {getTokenType(0) == IDENTIFIER && (currentLookaheadToken==null || (peekNode().getChildCount() > 1 || !tokenImage(0).equals("yield")))}#
  SCAN 1 {getTokenType(0) == IDENTIFIER}#
  =>
  InvocationArguments #MethodCall(+1)
 )*
;

ClassOrInterfaceBodyDeclaration#interface :
  Initializer
  |
  TypeDeclaration
  |
  ConstructorDeclaration
  |
  MethodDeclaration
  |
  FieldDeclaration
  |
  Statement
  |
  FormalComment
;

EnhancedForStatement :
   <FOR> <LPAREN> 
   (
    (<IDENTIFIER> ASSERT (<COLON>) =>||)
    |
    LocalVariableDeclaration 
   )
   <COLON> =>|| Expression <RPAREN> Statement
;

ArrayInitializer# :
  "{" 
     [ VariableInitializer
        ( SCAN 2 "," VariableInitializer )* ] [ "," ] 
  "}"
;

/*
VariableInitializer :
  SCAN 3
  ArrayInitializer
  |
  Expression
;

NoVarDeclaration :
   {permissibleModifiers = EnumSet.of(FINAL);}#
   Modifiers 
   [Type ASSERT ~(<COMMA>|<RPAREN>|<IDENTIFIER>)=>||] 
   =>|| 
   VariableDeclarator ( <COMMA> VariableDeclarator )*
;
*/

AssignmentExpression :
  {
    Expression lhs;
  }
  TernaryExpression {lhs = (Expression) peekNode();}
  [
    //SCAN 1 {lhs.isAssignableTo()} => 
    AssignmentOperator Expression
  ]
;

TOKEN :
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["o","O","s","S","i","I","l","L","w","W"])?
      | <HEX_LITERAL> (["o","O","s","S","i","I","l","L","w","W"])?
      | <BINARY_LITERAL> (["o","O","s","S","i","I","l","L","w","W"])?
      | <OCTAL_LITERAL> (["o","O","s","S","i","I","l","L","w","W"])?
  >
  |
  <FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D","w","W"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D","w","W"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D","w","W"])?
      | (["0"-"9"])+ ["f","F","d","D"]
  >  
;  
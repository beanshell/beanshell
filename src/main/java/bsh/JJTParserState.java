/*****************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one                *
 * or more contributor license agreements.  See the NOTICE file              *
 * distributed with this work for additional information                     *
 * regarding copyright ownership.  The ASF licenses this file                *
 * to you under the Apache License, Version 2.0 (the                         *
 * "License"); you may not use this file except in compliance                *
 * with the License.  You may obtain a copy of the License at                *
 *                                                                           *
 *     http://www.apache.org/licenses/LICENSE-2.0                            *
 *                                                                           *
 * Unless required by applicable law or agreed to in writing,                *
 * software distributed under the License is distributed on an               *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY                    *
 * KIND, either express or implied.  See the License for the                 *
 * specific language governing permissions and limitations                   *
 * under the License.                                                        *
 *                                                                           *
 *                                                                           *
 * This file is part of the BeanShell Java Scripting distribution.           *
 * Documentation and updates may be found at http://www.beanshell.org/       *
 * Patrick Niemeyer (pat@pat.net)                                            *
 * Author of Learning Java, O'Reilly & Associates                            *
 *                                                                           *
 *****************************************************************************/
/* Generated By:JJTree: Do not edit this line. src/bsh/JJTParserState.java */
package bsh;

/**
 * The Class JJTParserState.
 */
class JJTParserState {

    /** The nodes. */
    private final java.util.Stack nodes;
    /** The marks. */
    private final java.util.Stack marks;
    /** The sp. */
    private int sp; // number of nodes on stack
    /** The mk. */
    private int mk; // current mark
    /** The node created. */
    private boolean node_created;

    /**
     * Instantiates a new JJT parser state.
     */
    JJTParserState() {
        this.nodes = new java.util.Stack();
        this.marks = new java.util.Stack();
        this.sp = 0;
        this.mk = 0;
    }

    /**
     * Node created.
     *
     * @return true, if successful
     *
     * Determines whether the current node was actually closed and
     * pushed. This should only be called in the final user action of a
     * node scope.
     */
    boolean nodeCreated() {
        return this.node_created;
    }

    /**
     * Reset.
     *
     * Call this to reinitialize the node stack. It is called
     * automatically by the parser's ReInit() method.
     */
    void reset() {
        this.nodes.removeAllElements();
        this.marks.removeAllElements();
        this.sp = 0;
        this.mk = 0;
    }

    /**
     * Root node.
     *
     * @return the node
     *
     * Returns the root node of the AST. It only makes sense to call
     * this after a successful parse.
     */
    Node rootNode() {
        return (Node) this.nodes.elementAt(0);
    }

    /**
     * Push node.
     *
     * @param n
     *            the n
     * Pushes a node on to the stack. */
    void pushNode(final Node n) {
        this.nodes.push(n);
        ++this.sp;
    }

    /**
     * Pop node.
     *
     * @return the node
     *
     * Returns the node on the top of the stack, and remove it from the
     * stack.
     */
    Node popNode() {
        if (--this.sp < this.mk)
            this.mk = ((Integer) this.marks.pop()).intValue();
        return (Node) this.nodes.pop();
    }

    /**
     * Peek node.
     *
     * @return the node
     * Returns the node currently on the top of the stack. */
    Node peekNode() {
        return (Node) this.nodes.peek();
    }

    /**
     * Node arity.
     *
     * @return the int
     *
     * Returns the number of children on the stack in the current node
     * scope.
     */
    int nodeArity() {
        return this.sp - this.mk;
    }

    /**
     * Clear node scope.
     *
     * @param n
     *            the n
     */
    void clearNodeScope(final Node n) {
        while (this.sp > this.mk)
            this.popNode();
        this.mk = ((Integer) this.marks.pop()).intValue();
    }

    /**
     * Open node scope.
     *
     * @param n
     *            the n
     */
    void openNodeScope(final Node n) {
        this.marks.push(new Integer(this.mk));
        this.mk = this.sp;
        n.jjtOpen();
    }

    /**
     * Close node scope.
     *
     * @param n
     *            the n
     * @param num
     *            the num
     *
     * A definite node is constructed from a specified number of
     * children. That number of nodes are popped from the stack and
     * made the children of the definite node. Then the definite node
     * is pushed on to the stack.
     */
    void closeNodeScope(final Node n, int num) {
        this.mk = ((Integer) this.marks.pop()).intValue();
        while (num-- > 0) {
            final Node c = this.popNode();
            c.jjtSetParent(n);
            n.jjtAddChild(c, num);
        }
        n.jjtClose();
        this.pushNode(n);
        this.node_created = true;
    }

    /**
     * Close node scope.
     *
     * @param n
     *            the n
     * @param condition
     *            the condition
     *
     * A conditional node is constructed if its condition is true. All
     * the nodes that have been pushed since the node was opened are
     * made children of the the conditional node, which is then pushed
     * on to the stack. If the condition is false the node is not
     * constructed and they are left on the stack.
     */
    void closeNodeScope(final Node n, final boolean condition) {
        if (condition) {
            int a = this.nodeArity();
            this.mk = ((Integer) this.marks.pop()).intValue();
            while (a-- > 0) {
                final Node c = this.popNode();
                c.jjtSetParent(n);
                n.jjtAddChild(c, a);
            }
            n.jjtClose();
            this.pushNode(n);
            this.node_created = true;
        } else {
            this.mk = ((Integer) this.marks.pop()).intValue();
            this.node_created = false;
        }
    }
}
